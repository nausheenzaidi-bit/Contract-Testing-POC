type A2AResult implements DsContentModelResult {
  article: StandaloneContentModule
  type: ContentModuleType!
  contentID: String!
  score: Float!
}

type A2VResult implements DsContentModelResult {
  video: StandaloneContentModule
  type: ContentModuleType!
  contentID: String!
  score: Float!
}

type Action {
  download: Allowed
  list: Allowed
  play: Allowed
}

enum Actions {
  CREATED
  UPDATED
  DELETED
}

input AddAlertRankInput {
  alertRanks: [AlertRankInput!]
}

type AddAlertRankResponse {
  status: String!
  message: String
}

type AdsAdSize {
  width: Int
  height: Int
}

"""
AdsChannelConfiguration | Ads API
----------------------------------------------
Provides the ad registry and configuration for the Channel entity. This includes a registry for the
top-level view, as well as each section or grouping for the channel.
"""
type AdsChannelConfiguration {
  adUnitPath: String!
  registry: AdsDeployedState!
  configuration: AdsModuleConfiguration
  groupings: [AdsChannelGroupingConfiguration]
}

"""
AdsChannelGroupingConfiguration | Ads API
----------------------------------------------
A mapping of ad slot registries for each grouping in a Channel. The id property maps to an id of
each of the groupings for the channel.
"""
type AdsChannelGroupingConfiguration {
  id: String!
  adUnitPath: String!
  registry: AdsDeployedState!
}

"""
 AdsConfiguration | Ads API
 ----------------------------------------------
Configuration related to serving ads. Provides the ad slot registry as well as the configuration
for the web ad library, AdFuel.
"""
type AdsConfiguration {
  adUnitPath: String!
  registry: AdsDeployedState!
  configuration: AdsModuleConfiguration
}

type AdsDeployedState {
  error: String
  hasInViewRefresh: Boolean
  hasRealTimeAdInsertion: Boolean
  inViewRefreshCount: Int
  inViewRefreshInterval: Int
  isSingleton: Boolean
  name: String
  rtaiBuffer: Int
  rtaiInitialPlacement: Int
  rtaiMaxNoOfAds: Int
  rtaiOffset: Int
  rtaiParentSelector: String
  safeFrameOverlayExpansion: Boolean
  safeFrameAllowPushExpansion: Boolean
  safeFrameConfig: Boolean
  safeFrameSandboxMode: Boolean
  slots: [AdsSlot]
  tagForChildDirectedTreatment: Boolean
  targetings: [AdsTargeting]
  template: String
}

type AdsHistory {
  modifiedBy: String
  modifiedOn: Float
  area: String
  oldValue: String
  newValue: String
}

"""
AdsModuleConfiguration | Ads API
----------------------------------------------
Provides an ad configuration JSON blob that can be parsed and passed to AdFuel when content is
rendered in a web view or in a web browser.
"""
type AdsModuleConfiguration {
  """Configuration for AdFuel in strigified JSON"""
  jsonBlob: String!
}

type AdsRegistryDetailItem {
  name: String
  description: String
  lastDeployedOn: Date
  nameLowered: String
  slots: [String]
  adUnitPath: String
  error: String
}

type AdsSlot {
  name: String
  adSizes: [AdsAdSize]
  targetings: [AdsTargeting]
  adUnitPath: String
  isResponsive: Boolean
  hasInViewRefresh: Boolean
  isFluid: Boolean
  isInheritAdUnitFromRegistry: Boolean
  safeFrameAllowOverlayExpansion: Boolean
  safeFrameAllowPushExpansion: Boolean
  safeFrameConfig: Boolean
  safeFrameSandboxMode: Boolean
  inViewRefreshCount: Int
  inViewRefreshInterval: Int
  viewports: [AdsViewport]
}

type AdsTargeting {
  key: String
  value: String
}

type AdsViewport {
  name: String
  width: Int!
  height: Int!
  fluid: Boolean
  sizes: [String]
}

type AlertAnalytics {
  genres: [AlertGenre!]!
  gamecastType: AlertGamecastType
}

input AlertAnalyticsInput {
  genres: [AlertGenre!]!
  gamecastType: AlertGamecastType
}

enum AlertCategory {
  news
  highlights
  viral
  creators
}

type AlertDestination {
  contentModuleId: String
  tagUUID: String!
}

input AlertDestinationInput {
  contentModuleId: String
  tagUUID: String!
  tagDisplayName: String
}

enum AlertGamecastType {
  pregame
  postgame
  halftime
  overtime
}

enum AlertGenre {
  viral
  news
  sensitive
  betting
  closeGame
  highlights
  tuneIn
  automated
}

input AlertInput {
  type: AlertTypes!
  value: Boolean!
}

type AlertMediaAttachment {
  """This is the file extension of the media"""
  mediaType: AlertMediaType!

  """This is the url for the media"""
  mediaUrl: String!
  height: String
  width: String

  """Video reference to support video as media attachment"""
  editId: String
}

input AlertMediaAttachmentInput {
  """This is the file extension of the media"""
  mediaType: AlertMediaType!

  """This is the url for the media"""
  mediaUrl: String!
  height: String
  width: String

  """Video reference to support video as media attachment"""
  editId: String
}

enum AlertMediaType {
  jpg
  png
  video
}

type AlertPreference {
  type: AlertTypes!
  enabled: Boolean!
}

type AlertRank {
  rank: Int!
  pushNotification: PushNotification!
}

input AlertRankInput {
  pushNotificationId: ID!

  """The values for the alert rank. E. g. [5, 10, 25, 50, 100]"""
  rank: Int
}

enum AlertRegion {
  """Andorra"""
  AD

  """United Arab Emirates (the)"""
  AE

  """Albania"""
  AL

  """Angola"""
  AO

  """Argentina"""
  AR

  """American Samoa"""
  AS

  """Austria"""
  AT

  """Australia"""
  AU

  """Bosnia and Herzegovina"""
  BA

  """Barbados"""
  BB

  """Belgium"""
  BE

  """Bulgaria"""
  BG

  """Bahrain"""
  BH

  """Bermuda"""
  BM

  """Bolivia (Plurinational State of)"""
  BO

  """Brazil"""
  BR

  """Bahamas (the)"""
  BS

  """Belize"""
  BZ

  """Canada"""
  CA

  """Chile"""
  CL

  """Cameroon"""
  CM

  """Colombia"""
  CO

  """Costa Rica"""
  CR

  """CuraÃ§ao"""
  CW

  """Cyprus"""
  CY

  """Czechia"""
  CZ

  """Germany"""
  DE

  """Denmark"""
  DK

  """Dominican Republic (the)"""
  DO

  """Algeria"""
  DZ

  """Ecuador"""
  EC

  """Estonia"""
  EE

  """Egypt"""
  EG

  """Spain"""
  ES

  """Finland"""
  FI

  """France"""
  FR

  """United Kingdom of Great Britain and Northern Ireland (the)"""
  GB

  """Georgia"""
  GE

  """Ghana"""
  GH

  """Greece"""
  GR

  """Guatemala"""
  GT

  """Guam"""
  GU

  """Guyana"""
  GY

  """Hong Kong"""
  HK

  """Honduras"""
  HN

  """Croatia"""
  HR

  """Hungary"""
  HU

  """Indonesia"""
  ID

  """Ireland"""
  IE

  """Israel"""
  IL

  """India"""
  IN

  """Italy"""
  IT

  """Jordan"""
  JO

  """Jamaica"""
  JM

  """Kenya"""
  KE

  """Kuwait"""
  KW

  """Lebanon"""
  LB

  """Lithuania"""
  LT

  """Luxembourg"""
  LU

  """Latvia"""
  LV

  """Morocco"""
  MA

  """Republic of North Macedonia"""
  MK

  """Marshall Islands"""
  MH

  """Mongolia"""
  MN

  """Northern Mariana Islands (The)"""
  MP

  """Mexico"""
  MX

  """Malaysia"""
  MY

  """Nicaragua"""
  NI

  """Netherlands (the)"""
  NL

  """Norway"""
  NO

  """New Zealand"""
  NZ

  """Panama"""
  PA

  """Peru"""
  PE

  """Philippines (the)"""
  PH

  """Pakistan"""
  PK

  """Poland"""
  PL

  """Puerto Rico"""
  PR

  """Portugal"""
  PT

  """Palau"""
  PW

  """Paraguay"""
  PY

  """Romania"""
  RO

  """Serbia"""
  RS

  """Saudi Arabia"""
  SA

  """Sweden"""
  SE

  """Singapore"""
  SG

  """Slovenia"""
  SI

  """Slovakia"""
  SK

  """Senegal"""
  SN

  """El Salvador"""
  SV

  """Thailand"""
  TH

  """Trinidad and Tobago"""
  TT

  """Taiwan (Province of China)"""
  TW

  """Tanzania, United Republic of"""
  TZ

  """Ukraine"""
  UA

  """Uganda"""
  UG

  """US Minor Outlying Islands"""
  UM

  """United States of America"""
  US

  """Uruguay"""
  UY

  """Venezuela (Bolivarian Republic of)"""
  VE

  """Virgin Islands (U.S.)"""
  VI

  """Zambia"""
  ZM

  """Zimbabwe"""
  ZW
}

enum AlertTypes {
  scores @deprecated(reason: "This alert type is deprecated and will be removed in a future version")
  news
  viral
  creators
  highlights
  spoilers
}

type AllowAll {
  allowAll: Boolean
}

type Allowed {
  allowed: Boolean
}

type Article {
  uuid: String!
  primaryTag: TagV2!
  tenant: String
  contentType: String!

  """Ads Configuration | Ads API"""
  adsConfig: AdsConfiguration
  schemaVersion: String
  cmsId: String!
  contentSubtype: String
  created: String @deprecated(reason: "use field createdAt which is a correctly typed Date")
  changed: String @deprecated(reason: "use field updatedAt which is a correctly typed Date")
  publishedDateTime: Date
  isPublished: Boolean!
  isAdSensitive: Boolean
  isEvergreen: Boolean
  isPtScheduled: Boolean
  hideBetModule: Boolean
  title: String!
  language: String
  displayId: Int
  legacy: Boolean
  image: Image
  metatags: [PageMetatags]
  description: String
  slug: String
  ampUrl: String
  tags: [TagV2]
  betTags: [TagV2]
  containsGeoblockedContent: Boolean
  author: ArticleAuthor
  slides: [Slide]
  createdAt: Date
  updatedAt: Date
  _id: MongoID!
  hash: String

  """
  trendingRank | Data Services API
  
  Returns the Trending Rank from [1,100]. Returns null if not trending.
  """
  trendingRank: Int
  recommendedVideos(countryCode: String, version: Int = 0, aspectRatio: AspectRatio = Any, limit: Int = 10): [A2VResult!]!
  recommendedArticles(version: Int = 0, limit: Int = 10): [A2AResult!]!
  statsBetOffers(timezone: Int): StatsBetOffer
}

type ArticleAuthor {
  id: String
  name: String
  photoUrl: String
  title: String
  socialMediaHandles: [SocialMediaHandle]
}

type ArticleConnection {
  """The total number of items *found* by the search"""
  totalFound: Int!

  """The total number of items *returned* by the search"""
  totalReturned: Int!
  edges: [ArticleEdge!]!
  pageInfo: PageInfo!
}

type ArticleEdge {
  cursor: String!
  node: Article!
}

input ArticleFindManyParametersInput {
  """
  The term to search for.
  
  Requires a minimum of 3 characters to start getting results.
  
  Supports passing (1) "OR/AND" boolean operator in queries.
  
  (example OR: "nba OR nfl") (example AND: "coach AND LeBron")
  """
  query: String

  """
  List of tag UUIDs to apply to the search. Multiple UUIDs will be treated as an *OR* operation
  """
  tagUUIDList: [String!]

  """Filter search results to ARTICLE or SLIDESHOW types"""
  type: ArticleType

  """
  Filter search results by a date range of when the articles were created.
  
  The range is inclusive of the dates provided (ie. >= <=)
  """
  createdDateRange: DateRangeFilter

  """
  Filter search results by a date range of when the articles were updated.
  
  The range is inclusive of the dates provided (ie. >= <=)
  """
  updatedDateRange: DateRangeFilter

  """
  Filter search results by a date range of when the articles were published.
  
  The range is inclusive of the dates provided (ie. >= <=)
  """
  publishedDateRange: DateRangeFilter
}

enum ArticleType {
  ARTICLE
  SLIDESHOW
}

enum AspectRatio {
  Horizontal
  Vertical
  Any
}

type AssetConnection {
  edges: [AssetEdge]
  nodes: [SearchResult]
  pageInfo: PageInfo
  totalCount: Int
}

type AssetEdge {
  cursor: String
  node: SearchResult
}

type Author {
  """The author name for internal articles"""
  name: String
}

type Avatar {
  file_name: String
  url: String
}

type Badge {
  id: String
  name: String
  description: String
  badge_icon_url: String
  mimetype: String
}

type BadgeComponent {
  awarded_at: String
  badge: Badge
}

type BillingOrder {
  scope: String
  value: Int
}

type BlockedContent {
  type: ContentModuleType!
  contentID: String!
  insertedAt: Date!
}

type blockProfileResponse {
  id: String
  nickname: String
}

type Brand {
  id: Identifier
  primary: Boolean
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

enum Category {
  news
  highlights
  viral
  creators
  spoilers
}

enum CategoryType {
  push
  email
}

type Channel {
  uuid: String!
  tag: TagV2!
  tenant: String
  type: ChannelType
  groupingList: [GroupingHeader]

  """Ads Channel Configuration | Ads API"""
  adsConfig: AdsChannelConfiguration
  schemaVersion: String
  cmsId: String!
  isPublished: Boolean
  language: String
  title: String
  headline: String
  isTemplate: Boolean
  created: String @deprecated(reason: "use field createdAt which is a correctly typed Date")
  changed: String @deprecated(reason: "use field updatedAt which is a correctly typed Date")
  createdAt: Date
  updatedAt: Date
  metatags: [PageMetatags]
  gameState: GameState
  components: [ChannelComponent]!
  groupings(
    """The groupHeader id string to filter by"""
    filter: String
  ): [Grouping]
  _id: MongoID!
  pinnedContentModule: ContentModule
}

type ChannelComponent {
  tagUUID: String
  tagSlug: String
  tagType: String
  semanticID: SemanticID
  semanticType: SemanticType
  isDomesticOnly: Boolean
  weight: Int
  headline: String
  subheadline: String
  description: String
  uuid: String!
  link: Link
  images: [ImageWithStyle]
  interlacingInterval: Int
  tagData: [TagV2]
  watchInfo(
    """
    Optionally specify a specific affiliate to return. If omitted all affiliates will be returned
    """
    providerName: String
  ): [WatchInfo]
  userTags(tenant: Tenant!): [TagV2]
  contents(
    """
    A list of States to filter content modules by. Default value: PROGRAMMED
    """
    state: [ModuleState] = [PROGRAMMED]

    """Limit the number of returned Content Modules. Defaults to 150"""
    limit: Int = 150
    contentType: [ContentModuleType]
  ): [ContentModule]
  contentsConnection(
    """
    A list of States to filter content modules by. Default value: PROGRAMMED
    """
    state: [ModuleState] = [PROGRAMMED]

    """first"""
    first: Int

    """last"""
    last: Int

    """before"""
    before: ContentCursor

    """after"""
    after: ContentCursor

    """paginationControl"""
    paginationControl: [PaginationControl]
  ): ContentsConnection

  """
  dataServicesTagData | Data Services API
  
  Returns TagV2s according to the feature logic demanded by the given semanticID using data services.
  """
  dataServicesTagData(limit: Int = 10): [TagV2!]!
  userAlerts(limit: Int = 50, tenant: Tenant!): [PushNotification!]
  chat: ChatModule
  userContents(
    """Users LiveLike ProfileId"""
    profileID: String

    """Optional offset for pagination. Skips the first N items. Default: 0"""
    offset: Int

    """Optional limit for number of items to return. Default: 150, Max: 200"""
    limit: Int
  ): [StandaloneContentModule]
  statsGamecast: StatsGamecast
  statsStandings(season: Int, filter: String): StatsStanding
  statsSchedule(season: Int, timezone: Int): StatsSchedule
  statsScores(league: String, context: String, date: String, timezone: Int, locale: String): Scores
  userInfo(profileId: String, tenant: Tenant!): User
}

"""
ChannelRecommenderResult | Data Services API
Encapsulates all data related to the BR Channel Recommender Data Science Model.
"""
type ChannelRecommenderResult {
  tagV2: TagV2!
  score: Float!
}

type ChannelStreamMetaData {
  id: String
  semanticID: SemanticID
  tagUUID: String
  weight: Float
  _id: MongoID
  contents(
    """
    A list of States to filter content modules by. Default value: PROGRAMMED
    """
    state: [ModuleState] = [PROGRAMMED]

    """Limits the number of returned Content Modules."""
    limit: Int

    """Defined which type of content is returned."""
    contentType: [ContentModuleType]
  ): [ContentModule]
}

enum ChannelType {
  League
  SmallTeam
  PopularTeam
  Interest
  GameCast
  Home
  Following
  FollowingAddTags
  Alerts
  Discovery
  Creator
  User
  Onboarding
  OnboardingAddTags
  Scores
}

type ChatModule {
  chatroom: String
}

type Clock {
  hours: String
  milliseconds: String
  minutes: String
  seconds: String
  stoppage: String
}

type Competitor {
  hash: String
  description: String
  draws: String
  losses: String
  market: String
  name: String
  overtime_losses: String
  rank: String
  sportradar_id: String
  wins: String
  sport: Sport
  league: League
  tournaments(id: ID): [Tournament]
  leagues(id: ID): [League]
  id: ID
  team_alias: String
  team_abbr: String
  display_name_1: String
  display_name_2: String
  header_image_bucket: String
  logo_dark: String
  logo_light: String
  logo_split: String
}

type Competitors {
  competitors: [Competitor]
  total: Int
  index_start: Int
  index_end: Int
}

type Component {
  type: String
  weight: Float
  headline: String
  subheadline: String
  description: String
  startTime: Date
  endTime: Date
  link: Link
  id: String
  uuid: String!
  format: String
  orientation: String
  isFavoriteTeam: Boolean
  image: Image
  images: [ImageWithStyle]
  content: [Content]
  _id: MongoID

  """The reference stream"""
  referenceStream: ReferenceStream
}

"""
The `ComponentCursor` scalar type is a base64 encoded string that represents an opaque and unique identifier for Page components.
"""
scalar ComponentCursor

type ComponentEdge {
  cursor: ComponentCursor!
  node: Component!
}

type ComponentModule {
  """Hashed string used for sharing information with other graphs"""
  hash: String
  semanticID: SemanticID
  tag(tenant: Tenant!): TagV2
  position: Int!
  isPositionLocked: Boolean
  positionLockExpiresAt: Date

  """Date and time that the Content Modules was programmed into the Channel"""
  insertedAt: Date
  isPinned: Boolean
  widgets: [UGCWidget]
}

type ComponentsConnection {
  totalCount: Int!
  edges: [ComponentEdge!]!
  pageInfo: PageInfo!
}

type Conference {
  league: League
  name: String
  sport: Sport
  sportradar_id: String
  divisions(id: ID): [Division]
  teams(id: ID): [Competitor]
  id: ID
}

type Conferences {
  conferences: [Conference]
  total: Int
  index_start: Int
  index_end: Int
}

type ConfigJson {
  schemaVersion: String
  tenant: String
  uuid: String!
  cmsId: String!
  isPublished: Boolean
  language: String
  title: String
  created: String
  changed: String
  uri: String!
  jsonBlob: String
  _id: MongoID!
}

type Content {
  hash: String
  weight: Float
  allowedTypes: [String]
  filters: ContentFilters
  sort: ContentSort
  clip: String @deprecated(reason: "This field will be removed. Please use the \"clips\" (plural) field to get Video entity data")
  event: String @deprecated(reason: "This field is deprecated. Please use the \"events\" (plural) field to get the full Event entity")
  liveStream: String
  league: String
  tournament: String @deprecated(reason: "This field is deprecated. Please use the \"tournaments\" (plural) field to get the full Tournament entity")
  team: String @deprecated(reason: "This field is deprecated. Please use the \"teams\" (plural) field to get the full Competitor entity")
  product: [Product]
  form: ContentForm
  show: ContentShow
  image: Image
  item: Item
  stream: StreamMetaData
  channelStream: ChannelStreamMetaData
  _id: MongoID
  clips: [Video]
  contentModules: [ContentModule]
  episodes: [Show]
  events: [Event]
  series: [Series]
  teams: [Competitor]
  tournaments: [Tournament]
}

"""The Brand or Source for content. Primarily for External Articles"""
type ContentBrand {
  source: String!
  tenant: String
  uuid: String!
  cmsId: String!
  isPublished: Boolean
  isDeleted: Boolean
  language: String
  brandSourceUrls: [String]
  isPartner: Boolean
  logos: [ImageWithStyle]
  name: String!
}

"""
The `ContentCursor` scalar type is a base64 encoded string
that represents an opaque and unique identifier for Content Modules within a ChannelComponent.
"""
scalar ContentCursor

type ContentEdge {
  cursor: ContentCursor!
  node: ContentModule!
}

type ContentFilters {
  isFavoriteTeam: Boolean
  maxItems: Float
  status: [String]
  timeWindow: [Float]
  shows: [String]
  collections: [String]
  tags: [String]
  _id: MongoID
}

type ContentForm {
  element: FormElement
}

input ContentLibrarySearchParametersInput {
  """
  The term to search for.
  
  Requires a minimum of 3 characters to start getting results.
  
  Supports passing (1) "OR/AND" boolean operator in queries.
  
  (example OR: "nba OR nfl") (example AND: "coach AND LeBron")
  """
  query: String

  """
  List of tag UUIDs to apply to the search. Multiple UUIDs will be treated as an *OR* operation
  """
  tagUUIDList: [String!]

  """Filter search results to specific content types"""
  contentTypeFilter: [ContentSearchType!]

  """Provides the ability to search on specific source fields."""
  sourceType: SearchSource

  """
  Filter VideoV2 search results by whether or not a video is full length or a clip
  """
  videoContentTypeFilter: VideoContentTypeFilter

  """Whether or not the content should be scheduled in the Programming Tool"""
  isPtScheduled: Boolean

  """
  Filter search results by a date range of when the content was created.
  
  The range is inclusive of the dates provided (ie. >= <=)
  """
  createdDateRange: DateRangeFilter

  """
  Toggle using either parital-text match (ie. autocomplete) or full-text match.
  A different search algorithm will be run depending on this flag.
  Partial-Text match (ie. autocomplete) is the default.
  """
  useFullTextSearch: Boolean
}

union ContentLibrarySearchResult = Article | VideoV2 | Tweet

enum ContentLibrarySortDirection {
  ASC
  DESC
}

input ContentLibrarySortParametersInput {
  """sort by the date the content was created. (sorts on field createdAt)"""
  created: ContentLibrarySortDirection

  """
  sort by the date the content was last updated. (sorts on field updatedAt)
  """
  changed: ContentLibrarySortDirection

  """sort by the title of content"""
  title: ContentLibrarySortDirection
}

type ContentMetadata {
  video: VideoV2Metadata
}

interface ContentModule {
  id: ID!

  """Also known as Headline, that's the heading text of a content module."""
  title: String!

  """
  Also known as Commentary, short description of the content of a content module.
  """
  description: String!

  """
  Date and Time when a content module will not be visible anymore for end users. The state will be `UNPROGRAMMED`.
  """
  expiresAt: Date

  """
  Date and Time when a content module will start to be visible for end users. The state will be `SCHEDULED`.
  """
  scheduledDate: Date

  """
  List of possible states of content module. One of `SCHEDULED`, `PROGRAMMED` or `UNPROGRAMMED`.
  """
  state: ModuleState

  """
  List of Channels/Components (tag + semanticID) a content module is programmed to.
  """
  components: [ComponentModule]

  """Indicates if a push notification was sent to the content module."""
  isAlerted: Boolean

  """List of countries that a content module will be visible."""
  allowedCountries: [String]
  commentsEnabled: Boolean

  """Indicates to what tagUUID the content module was alerted to."""
  alertedChannelTagUUID: String

  """Date and time that a content module was last updated."""
  updatedAt: Date

  """Date and time that the Content Modules was created."""
  insertedAt: Date

  """
  Metadata containing community tag, author, and brand information for logos and display.
  """
  metaData: ModuleMetaData
  hidden: Boolean

  """
  Date and Time when a hidden content module will automatically become visible again.
  """
  hiddenExpiresAt: Date
}

input ContentModuleInput {
  id: ID
  contentId: ID!
  lastModifiedBy: String!
  channels: [TagComponent!]!
  title: String!
  description: String!
  thumbnail: String!
  contentType: ContentModuleType!
  orientation: ModuleOrientation
  expiresAt: Date
  scheduledDate: Date
  allowedCountries: [String]
  commentsEnabled: Boolean
  thumbnailAccreditation: String
  thumbnailCopyright: String
  updateProgrammingTimestamp: Boolean
  hidden: Boolean
  hiddenExpiresAt: Date
}

enum ContentModuleType {
  Article
  ExternalArticle
  StatsBetting
  StatsGamecast
  Tweet
  UGCImagePoll
  UGCTextPoll
  UGCPost
  VideoV2
  Mixed
}

type ContentsConnection {
  edges: [ContentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ContentSearchType {
  Article
  Tweet
  VideoV2
}

type ContentShow {
  id: String
  title: String
  image: Image
  weight: Float
  _id: MongoID
}

type ContentSort {
  field: String
  order: String
}

enum ContentType {
  VIDEO
  ARTICLE
  CHANNEL
  USER
}

scalar ContextFieldValue

type CreatePollResponse {
  created: Boolean!
  errorMsg: String
  poll: Poll
  status: String!
}

type CreatePostResponse {
  created: Boolean!
  errorMsg: String
  post: Post
  status: String!
}

type CreateProgramResponse {
  created: Boolean!
  errorMsg: String
  program: String
}

enum CreatorTier {
  Platinum
  Gold
  Silver
  Bronze
}

type Credit {
  billingOrders: [BillingOrder]
  id: String
  personId: ID
  role: String
}

type CustomLiveLikeUserReaction {
  id: String!
  clientId: String!
  targetId: String!
  reactionId: String!
  reactionSpaceId: String!
  customData: String
  reactedById: String!
  createdAt: String!
}

scalar Date

input DateRangeFilter {
  """
  Upper value of the createdDateRange.
  
  Must be an ISODate. The format is YYYY-MM-DD HH:MM.SS.millis (ex. 2024-07-01T00:00:00.000Z)
  """
  high: Date

  """
  Lower value of the createdDateRange.
  
  Must be an ISODate. The format is YYYY-MM-DD HH:MM.SS.millis (ex. 2024-04-01T00:00:00.000Z)
  """
  low: Date
}

scalar DateTime

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type DeleteVideoContentModulesResult {
  deletedCount: Int!
  deletedModuleIds: [String!]!
  contentId: String!
}

type Device {
  id: Int!
  token: String!
  type: String!
  appVersion: String!
  osVersion: String!
}

input DeviceInput {
  token: String!
  type: DeviceType!
  appVersion: String!
  osVersion: String!
}

enum DeviceType {
  ANDROID
  IPHONE
  IPAD
}

type Division {
  conference: Conference
  league: League
  name: String
  sport: Sport
  sportradar_id: String
  id: ID
  division_alias: String
  teams(id: ID): [Competitor]
}

type Divisions {
  divisions: [Division]
  total: Int
  index_start: Int
  index_end: Int
}

interface DsContentModelResult {
  type: ContentModuleType!
  contentID: String!
}

type DsModel {
  name: String!
  defaultVersion: Int!
}

"""
A string representing a duration conforming to the ISO8601 standard,
such as: P1W1DT13H23M34S
P is the duration designator (for period) placed at the start of the duration representation.
Y is the year designator that follows the value for the number of years.
M is the month designator that follows the value for the number of months.
W is the week designator that follows the value for the number of weeks.
D is the day designator that follows the value for the number of days.
T is the time designator that precedes the time components of the representation.
H is the hour designator that follows the value for the number of hours.
M is the minute designator that follows the value for the number of minutes.
S is the second designator that follows the value for the number of seconds.

Note the time designator, T, that precedes the time value.

Matches moment.js, Luxon and DateFns implementations
,/. is valid for decimal places and +/- is a valid prefix
"""
scalar Duration

type Element {
  content: ElementContent
  contentType: String
  order: Int
}

type ElementContent {
  html: String
  media: VideoV2
  image: Image
  url: String
  wordCount: Float
}

enum EnumTagGroupType {
  Suggested
  Location
  Programming
  League
}

enum EnumTagV2ChannelState {
  PreGame
  LiveGame
  PostGame
  Standard
}

type Event {
  hash: String
  card_type: String
  color_1: String
  color_2: String
  derived_status: String
  free_event: Boolean
  free_preview: Boolean
  has_media: Boolean
  media_asset_id_live: String
  media_asset_id_vod: String
  hidden: Boolean
  is_live: Boolean
  league: League
  medium_vod: Boolean
  recommended: Boolean
  scheduled_utc: String
  season: String
  season_type: String
  series_name: String
  series_id: Int
  sponsor_text: String
  sport: Sport
  sportradar_id: String
  status: String
  game: Game
  territories_available: [Territories]
  trending: Boolean
  week: String
  time_zone: String
  updated_at: String
  tournament: Tournament
  venue: Venue
  home: Competitor
  away: Competitor
  id: ID
  title: String
  home_team_points: String
  away_team_points: String
  event_image: String
  header_image_bucket: String
  event_image_bucket: String
  period: String
  type: String
  logo_dark: String
  logo_light: String
}

input EventFilterInput {
  start_date: String
  end_date: String
  count_start: String
  count_end: String
  sort: EventSort
  order: SortDirections
  media_filter: String
  has_media: Boolean
  season: Int
  territories: Territories
  type: EventTypes
  filterId: [EventFilterType]
}

enum EventFilterNames {
  series
  tournament
  team
  league
  sport
  sportRadar
}

input EventFilterType {
  name: EventFilterNames!
  id: String!
}

type Events {
  events: [Event]
  total: Int
  index_start: Int
  index_end: Int
}

enum EventSort {
  date
  rating
}

enum EventTypes {
  manual
  match
}

type ExternalArticle {
  id: ID!
  source: String!
  providerName: String!
  brand(tenant: Tenant!): ContentBrand
  url: String!
  created: Date!
}

input FacetRequest {
  field: String!
  first: Int
}

type FacetResponse {
  facetResults: [FacetResult!]
  field: String!
}

type FacetResult {
  count: Int!
  value: String!
}

type Feed {
  code: String
  link: String
  logo: String
  description: String
  shows: [Show]
}

enum Feeds {
  CDFH_CL
  TNTSPO_AR
}

input Filter {
  field: String!
  values: [String!]
}

type FollowingMetadata {
  primaryLabel: String
  secondaryLabel: String
  chipLabel: String
  categoryLogo: Image
  uuid: String
  weight: Float
}

type FormElement {
  weight: Float
  type: String
  headline: String
  options: JSON
  _id: MongoID
}

type Game {
  sportradar_id: String
  away: Team
  gameDate: GameDate
  gameProgress: GameProgress
  home: Team
  id: String
  name: String
  score: Score
  sourceGameId: String
  sport: SportMetaData
  stateStatus: StateStatus
  status: String
  weekId: String
}

type GamecastAnalytics {
  awayTeamTag: Tag
  coverageType: String
  gamePeriod: Int
  gamePermalinkTag: Tag
  gameStart: String
  headlineTitle: String
  headlineTitleAbbreviated: String
  homeTeamTag: Tag
  seasonType: String
  tournamentName: String
}

type GamecastMetadata {
  gamePermalink: String
  analytics: GamecastAnalytics
  scoreBoard: GamecastScoreboard
}

type GamecastProgress {
  header: String
  primary: String
  footer: String
}

type GamecastScoreboard {
  id: String
  status: String
  sport: String
  league: String
  gameDate: String
  teamOne: GamecastTeam
  teamTwo: GamecastTeam
  progress: GamecastProgress
}

type GamecastTeam {
  shortName: String
  score: String
  permalink: String
  name: String
  logo: String
  isWinner: Boolean!
  abbrev: String
  hasPossession: Boolean!
}

type GameDate {
  epoch: Int
  iso8501: String
}

type GameGroup {
  name: String
  current: Boolean
  games: [ScoresGame]
  events: [ScoresEvent]
}

type GameProgress {
  clock: Clock
  currentPeriod: String
  displayPrimary: String
  displaySecondary: String
  totalPeriods: String
}

enum GameState {
  PreGame
  LiveGame
  PostGame
  Standard
}

type Grouping {
  header: GroupingHeader
  components: [ChannelComponent]
}

type GroupingHeader {
  id: String
  title: String
  isDefault: Boolean
  applicableGameStates: [GameState]
  isDomesticOnly: Boolean
  image: Image

  """GameCast slug for this GroupingHeader"""
  slug: String

  """GameCast start time for this GroupingHeader"""
  gameStartTime: Date

  """GameCast end time for this GroupingHeader"""
  gameEndTime: Date
  visible: Boolean!
  visibleReason: VisibilityReason
}

type Identifier {
  id: String
  namespace: String
}

type Image {
  url: String!
  alt: String
  width: String
  height: String
  focalPointX: Float
  focalPointY: Float
  accreditation: String
  caption: String
  copyright: String
  _id: MongoID
}

input ImagePollInput {
  uploadId: ID!
  contentId: ID
  question: String!
  options: [ImagePollOptionInput!]
  timeout: String
  interactiveUntil: String
  tagUUIDs: [String!]!
  userAuth: String!
}

input ImagePollOptionInput {
  description: String!
  imageUrl: String!
}

enum ImageTypes {
  jpg
  png
}

type ImageWithStyle {
  image: Image
  style: String
  type: String
  _id: MongoID
}

type Item {
  headline: String
  subheadline: String
  description: String
  style: String
  link: Link
  startTime: Date
  endTime: Date
  images: [ImageWithStyle]
  _id: MongoID
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""
A field whose value is a JSON Web Token (JWT): https://jwt.io/introduction.
"""
scalar JWT

type League {
  alias: String
  current_season: String
  display_name: String
  name: String
  season_end: String
  season_start: String
  type: String
  id: ID
  sport: Sport
  display_name_short: String
}

type Leagues {
  leagues: [League]
  total: Int
  index_start: Int
  index_end: Int
}

type Legacy {
  league_id: Int
  sport_id: Int
}

type Limitation {
  adPlacement: AllowAll
  audioLanguage: AllowAll
  technicalQuality: AllowAll
  textLanguage: AllowAll
}

type Link {
  uri: String
  text: String
  _id: MongoID
}

type LiveLikeAlert implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the alert"""
  id: UUID!

  """Client identifier associated with this alert"""
  clientId: NonEmptyString!

  """Program identifier associated with this alert"""
  programId: UUID!

  """Information about the user that created the widget"""
  createdBy: LiveLikeWidgetCreator!

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Optional custom metadata for the widget"""
  customData: String

  """Additional widget attributes in key-value format"""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """List of sponsor IDs associated with this Alert"""
  sponsorIds: [UUID!]

  """Total number of unique users who interacted with the widget"""
  uniqueImpressionCount: NonNegativeInt

  """Contains count-based metrics such as interactions"""
  reportCount: LiveLikeWidgetReportCount

  """ISO8601 DateTime when the widget stops accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive"""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling"""
  publishDelay: Duration!

  """Program-scheduled datetime when the alert is expected to appear"""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created"""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget"""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published"""
  publishedAt: DateTimeISO

  """title of the alert"""
  title: NonEmptyString

  """text of the alert"""
  text: NonEmptyString

  """url of the body image"""
  imageUrl: URL

  """url of the link"""
  linkUrl: URL

  """label describing the link"""
  linkLabel: NonEmptyString
}

input LiveLikeAlertCreateInput {
  """ ID of the program to create the alert"""
  programId: UUID!

  """free-form field used for custom behaviors"""
  customData: String

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this Alert. 
  Note only valid sponsor ids will be linked to Alert.
  """
  sponsorIds: [UUID!]

  """ISO8601 duration hint for when a Widget should be timed out"""
  timeout: Duration

  """ISO8601 DateTime that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """title of the alert"""
  title: NonEmptyString

  """text of the alert"""
  text: NonEmptyString

  """url of the body image"""
  imageUrl: URL

  """url of the link"""
  linkUrl: URL

  """label describing the link"""
  linkLabel: NonEmptyString

  """Alert localized data"""
  localizedData: [LiveLikeAlertLocalizedInput!]
}

input LiveLikeAlertLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47 (RFC 5646) standard 
  """
  language: Locale!

  """title of the alert"""
  title: NonEmptyString

  """text of the alert"""
  text: NonEmptyString

  """label describing the link"""
  linkLabel: NonEmptyString
}

type LiveLikeApplication {
  clientId: NonEmptyString!
  name: String!
  organizationId: UUID!
  organizationName: NonEmptyString!
  imageUrl: URL!
  mediaUrl: URL!
  apiPollingInterval: PositiveInt!
  pubnubOrigin: NonEmptyString
  pubnubSubscribeKey: NonEmptyString
  pubnubPublishKey: NonEmptyString
  pubnubHeartbeatInterval: NonNegativeInt
  pubnubPresenceTimeout: NonNegativeInt
}

input LiveLikeAwardBadgeInput {
  badgeId: UUID!
  profileId: UUID!
}

type LiveLikeBadge implements LiveLikeNode {
  id: UUID!
  mimetype: NonEmptyString!
  description: NonEmptyString
  name: NonEmptyString!
  clientId: NonEmptyString!
  badgeIconUrl: URL!
  file: URL!
  attributes: [LiveLikeKeyValuePair!]
}

type LiveLikeBadgeCollection implements LiveLikeConnection {
  edges: [LiveLikeBadgeEdge!]
  page: LiveLikePage!
}

type LiveLikeBadgeEdge implements LiveLikeEdge {
  node: LiveLikeBadge!
  cursor: String
}

type LiveLikeBadgeProfile {
  badgeId: UUID!
  awardedAt: DateTimeISO!
  profile: LiveLikeProfile!
}

type LiveLikeBadgeProfileCollection {
  edges: [LiveLikeBadgeProfileEdge!]
  page: LiveLikePage!
}

type LiveLikeBadgeProfileEdge {
  node: LiveLikeBadgeProfile!
  cursor: String
}

"""Represents the progress of reward item associated with a badge."""
type LiveLikeBadgeRewardProgress {
  """Unique identifier of the reward item."""
  rewardItemId: UUID!

  """Name of the reward item."""
  rewardItemName: NonEmptyString!

  """Threshold amount required to earn this reward item."""
  rewardItemThreshold: NonNegativeInt!

  """Current amount the badge has accumulated toward this reward item."""
  currentRewardAmount: NonNegativeInt!
}

"""
Represents the reward progress tracking for a specific badge, including associated reward items and their progress.
"""
type LiveLikeBadgeRewardProgressCollection {
  """The badge for which the reward progress is being tracked."""
  badge: LiveLikeBadge!

  """
  A list of reward progress entries for each reward item under the badge.
  """
  badgeProgress: [LiveLikeBadgeRewardProgress!]
}

type LiveLikeBlockProfile implements LiveLikeNode {
  id: UUID!
  blockedProfileId: UUID!
  blockedByProfileId: UUID!
  blockedProfile: LiveLikeProfile!
  blockedByProfile: LiveLikeProfile!
}

type LiveLikeChatRoom implements LiveLikeNode {
  id: UUID!
  reactionSpaceId: UUID!
  title: String
  contentFilter: LiveLikeChatRoomContentFilterEnum!
  visibility: LiveLikeChatRoomVisibilityEnum!
  channels: LiveLikeChatRoomChannel!
  reactionPackIds: [UUID!]
  sponsorIds: [UUID!]
  tokenGates: [LiveLikeTokenGate!]
  createdAt: DateTimeISO!
}

type LiveLikeChatRoomChannel {
  chat: NonEmptyString!
  reactions: NonEmptyString!
  control: NonEmptyString!
}

type LiveLikeChatRoomCollection implements LiveLikeConnection {
  edges: [LiveLikeChatRoomEdge]
  page: LiveLikePage!
}

enum LiveLikeChatRoomContentFilterEnum {
  NONE
  FILTERED
  PRODUCER
}

input LiveLikeChatRoomCreateInput {
  title: NonEmptyString
  contentFilter: LiveLikeChatRoomContentFilterEnum
  visibility: LiveLikeChatRoomVisibilityEnum
  reactionPackIds: [UUID!]
  sponsorIds: [UUID!]
  tokenGates: [LiveLikeTokenGateInput!]
}

type LiveLikeChatRoomEdge implements LiveLikeEdge {
  node: LiveLikeChatRoom!
  cursor: String
}

input LiveLikeChatRoomsGetInput {
  page: PositiveInt
  clientId: NonEmptyString!
}

input LiveLikeChatRoomUpdateInput {
  id: UUID!
  title: NonEmptyString
  contentFilter: LiveLikeChatRoomContentFilterEnum
  visibility: LiveLikeChatRoomVisibilityEnum
  reactionPackIds: [UUID!]
  sponsorIds: [UUID!]
  tokenGates: [LiveLikeTokenGateInput!]
}

enum LiveLikeChatRoomVisibilityEnum {
  EVERYONE
  MEMBERS
}

input LiveLikeclaimUserQuestRewardInput {
  userQuestId: UUID!
  rewardsStatus: LiveLikeUserQuestRewardStatus!
}

type LiveLikeComment implements LiveLikeNode {
  id: UUID!
  parentCommentId: UUID
  commentBoardId: UUID!
  authorId: UUID!
  text: String
  commentDepth: NonNegativeInt!
  customData: NonEmptyString
  repliesCount: NonNegativeInt!
  createdAt: DateTimeISO!
  isReported: Boolean!
  commentReportsCount: NonNegativeInt!
  isDeleted: Boolean!
  deletedBy: UUID
  deletedAt: DateTimeISO
  author: LiveLikeProfile!
}

type LiveLikeCommentBoard implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  customId: String
  customData: String
  title: String
  contentFilter: LiveLikeContentFilterEnum!
  description: String
  allowComments: Boolean!
  repliesDepth: PositiveInt!
  commentsCount: NonNegativeInt!
  createdById: UUID!
  createdAt: DateTimeISO!
}

type LiveLikeCommentBoardBan implements LiveLikeNode {
  id: UUID!
  profileId: UUID!
  clientId: NonEmptyString!
  commentBoardId: UUID
  description: String
  bannedById: UUID!
  createdAt: DateTimeISO!
}

type LiveLikeCommentBoardBanCollection implements LiveLikeConnection {
  edges: [LiveLikeCommentBoardBanEdge!]
  page: LiveLikePage!
}

type LiveLikeCommentBoardBanEdge implements LiveLikeEdge {
  node: LiveLikeCommentBoardBan!
  cursor: String
}

input LiveLikeCommentBoardBanInput {
  profileId: UUID!
  commentBoardId: UUID
  description: String
}

input LiveLikeCommentBoardBansInput {
  profileId: UUID
  commentBoardId: UUID
  clientId: NonEmptyString
}

type LiveLikeCommentBoardCollection implements LiveLikeConnection {
  edges: [LiveLikeCommentBoardEdge]
  page: LiveLikePage!
}

type LiveLikeCommentBoardCount implements LiveLikeNode {
  id: UUID!
  commentsCount: NonNegativeInt!
  topLevelCommentsCount: NonNegativeInt!
}

input LiveLikeCommentBoardCreateInput {
  customId: NonEmptyString
  title: NonEmptyString
  description: NonEmptyString
  contentFilter: LiveLikeContentFilterEnum
  allowComments: Boolean
  repliesDepth: PositiveInt
  customData: NonEmptyString
}

type LiveLikeCommentBoardEdge implements LiveLikeEdge {
  node: LiveLikeCommentBoard!
  cursor: String
}

input LiveLikeCommentBoardsCountGetInput {
  commentBoardIds: [UUID!]!
}

input LiveLikeCommentBoardsGetInput {
  page: PositiveInt
  clientId: NonEmptyString!
  customId: NonEmptyString
  commentBoardIds: [UUID!]
}

input LiveLikeCommentBoardUpdateInput {
  id: UUID!
  customId: NonEmptyString
  title: NonEmptyString
  contentFilter: LiveLikeContentFilterEnum
  description: NonEmptyString
  allowComments: Boolean
  repliesDepth: PositiveInt
  customData: NonEmptyString
}

type LiveLikeCommentCollection implements LiveLikeConnection {
  edges: [LiveLikeCommentEdge]
  page: LiveLikePage!
}

input LiveLikeCommentCreateInput {
  commentBoardId: UUID!
  text: NonEmptyString!
  customData: NonEmptyString
}

type LiveLikeCommentEdge implements LiveLikeEdge {
  node: LiveLikeComment!
  cursor: String
}

input LiveLikeCommentRepliesGetInput {
  page: PositiveInt
  commentBoardId: UUID!
  parentCommentId: UUID!
  withoutDeletedThread: Boolean
}

input LiveLikeCommentReplyCreateInput {
  commentBoardId: UUID!
  parentCommentId: UUID!
  text: NonEmptyString!
  customData: NonEmptyString
}

type LiveLikeCommentReport implements LiveLikeNode {
  id: UUID!
  commentBoardId: UUID!
  commentId: UUID!
  description: String
  reportedById: UUID!
  reportStatus: LiveLikeCommentReportStatusEnum!
  reportedAt: DateTimeISO!
  comment: LiveLikeComment!
}

type LiveLikeCommentReportCollection implements LiveLikeConnection {
  edges: [LiveLikeCommentReportEdge]
  page: LiveLikePage!
}

input LiveLikeCommentReportCreateInput {
  commentId: UUID!
  description: NonEmptyString
}

type LiveLikeCommentReportEdge implements LiveLikeEdge {
  node: LiveLikeCommentReport!
  cursor: String
}

enum LiveLikeCommentReportStatusEnum {
  PENDING
  DISMISSED
}

input LiveLikeCommentsGetInput {
  page: PositiveInt
  commentBoardId: UUID!
}

input LiveLikeCommentsReportsGetInput {
  page: PositiveInt
  clientId: NonEmptyString!
  commentBoardId: UUID
  commentId: UUID
}

interface LiveLikeConnection {
  edges: [LiveLikeEdge]
  page: LiveLikePage
}

enum LiveLikeContentFilterEnum {
  FILTERED
  NONE
}

type LiveLikeEarnedBadge {
  id: UUID!
  badge: LiveLikeBadge!
  awardedAt: DateTimeISO!
}

type LiveLikeEarnedBadgeCollection {
  edges: [LiveLikeEarnedBadgeEdge!]
  page: LiveLikePage!
}

type LiveLikeEarnedBadgeEdge {
  node: LiveLikeEarnedBadge!
  cursor: String
}

interface LiveLikeEdge {
  node: LiveLikeNode
  cursor: String
}

type LiveLikeEmoji implements LiveLikeNode {
  id: UUID!
  name: NonEmptyString!
  file: URL!
  mimeType: NonEmptyString!
}

type LiveLikeEmojiCount implements LiveLikeNode {
  id: UUID!
  reactionsCount: NonNegativeInt!
}

type LiveLikeImagePoll implements LiveLikeWidgetBase & LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  programId: UUID!
  kind: LiveLikeWidgetKindEnum!
  customData: String
  filteredQuestion: String
  contentFilter: [String!]
  createdBy: LiveLikeWidgetCreator!
  userVote: LiveLikeWidgetInteraction @deprecated(reason: "Introduces cyclic dependency and ImagePoll cache issue")
  createdAt: DateTimeISO!
  scheduledAt: DateTimeISO
  publishedAt: DateTimeISO
  status: LiveLikeWidgetStatusEnum!
  pubnubEnabled: Boolean!
  uniqueImpressionCount: NonNegativeInt
  timeout: Duration!

  """The ISO8601 Date that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!

  """List of options for this prediction"""
  options: [LiveLikeImagePollOption!]!

  """List the sponsors ids with this Image Poll."""
  sponsorIds: [UUID!]

  """
  Delay (ISO8601) before the widget is published after scheduling (if applicable).
  """
  publishDelay: Duration!

  """
  Program-scheduled datetime when the widget is expected to appear (if applicable).
  """
  programDateTime: DateTimeISO

  """Report count information"""
  reportCount: LiveLikeWidgetReportCount
}

input LiveLikeImagePollCreateInput {
  """ID of the program to create the prediction for"""
  programId: UUID!

  """A free-form field used for custom behaviors"""
  customData: String

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!

  """List of options for this prediction, min 2 and max 4"""
  options: [LiveLikeImagePollCreateOptionInput!]!

  """A iso8601 duration hint for when a Widget should be timed out"""
  timeout: Duration

  """The ISO8601 DateTime that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this Image Poll. Note that only valid sponsor_ids will be linked to a Image Poll.
  """
  sponsorIds: [UUID!]

  """ImagePoll localized data"""
  localizedData: [LiveLikeImagePollLocalizedInput!]
}

input LiveLikeImagePollCreateOptionInput {
  """Description of a poll option"""
  description: NonEmptyString!

  """Image URL of a poll option"""
  imageURL: URL!

  """ImagePoll option localized data"""
  localizedData: [LiveLikeImagePollOptionLocalizedInput!]
}

input LiveLikeImagePollLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47 (RFC 5646) standard.
  """
  language: Locale!

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!
}

type LiveLikeImagePollOption implements LiveLikeNode {
  id: UUID!
  translatableFields: [String!]
  voteCount: Int
  imageUrl: URL!
  description: String!
  filteredDescription: String
  contentFilter: [String!]
}

input LiveLikeImagePollOptionLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47 (RFC 5646) standard.
  """
  language: Locale!

  """Description of a poll option"""
  description: NonEmptyString!
}

type LiveLikeImagePollVote implements LiveLikeWidgetInteractionBase {
  id: UUID!

  """ID of the profile associated with the image poll vote"""
  profileId: UUID!

  """ID of the widget associated with the image poll vote"""
  widgetId: UUID!
  widgetKind: LiveLikeWidgetInteractionEnum!

  """Image poll widget associated with the image poll vote"""
  widget: LiveLikeImagePoll!
  createdAt: String!

  """Rewards associated with the image poll vote"""
  rewards: [LiveLikeReward!]

  """Leaderboard rewards associated with the image poll vote"""
  leaderboardRewards: [LiveLikeLeaderboardReward!]

  """Vote option associated with the image poll vote"""
  optionId: UUID!
}

input LiveLikeImagePollVoteCreateInput {
  widgetId: UUID!
  optionId: UUID!
}

input LiveLikeImagePollVoteUpdateInput {
  id: UUID!
  widgetId: UUID!
  optionId: UUID!
}

"""Represents an image prediction widget."""
type LiveLikeImagePrediction implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the image prediction."""
  id: UUID!

  """Client identifier associated with this prediction."""
  clientId: NonEmptyString!

  """Program identifier associated with this prediction."""
  programId: UUID!

  """The question for the prediction to be made"""
  question: NonEmptyString!

  """List of options available for this prediction."""
  options: [LiveLikeImagePredictionOption!]!

  """List of all follow ups available for this prediction."""
  followUps: [LiveLikeImagePredictionFollowUp!]!

  """Optional custom metadata for the widget."""
  customData: String

  """Optional confirmation message for the widget."""
  confirmationMessage: String

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Total number of unique users who interacted with the widget."""
  uniqueImpressionCount: NonNegativeInt

  """List of sponsor IDs associated with this Image Prediction."""
  sponsorIds: [UUID!]

  """Contains count-based metrics such as interactions."""
  reportCount: LiveLikeWidgetReportCount

  """Additional widget attributes in key-value format."""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """Information about the user that created the widget."""
  createdBy: LiveLikeWidgetCreator!

  """The ISO8601 DateTime when the widget stops accepting interactions."""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds."""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive."""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling."""
  publishDelay: Duration!

  """Program-scheduled datetime when the prediction is expected to appear."""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created."""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget."""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published."""
  publishedAt: DateTimeISO
}

input LiveLikeImagePredictionCreateInput {
  """ID of the program to create the prediction for"""
  programId: UUID!

  """A free-form field used for custom behaviors"""
  customData: NonEmptyString

  """ The prompt or question for the prediction to be made """
  question: NonEmptyString!

  """ List of options for this prediction"""
  options: [LiveLikeImagePredictionCreateOptionInput!]!

  """Optional confirmation message for the widget."""
  confirmationMessage: String

  """A iso8601 duration hint for when a Widget should be timed out """
  timeout: Duration

  """ The ISO8601 DateTime that the widget will stop accepting interactions 
  """
  interactiveUntil: DateTimeISO

  """ Video playback time in milliseconds """
  playbackTimeMs: NonNegativeInt

  """ An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """ Links the sponsors with this Image Prediction. Note that only valid sponsor_ids will be linked to a Image Prediction.
  """
  sponsorIds: [UUID!]

  """Image Prediction localized data"""
  localizedData: [LiveLikeImagePredictionLocalizedInput!]
}

"""Represents a option for a image prediction."""
input LiveLikeImagePredictionCreateOptionInput {
  """Description of the option."""
  description: NonEmptyString!

  """Indicates whether this option is the correct answer"""
  isCorrect: Boolean

  """URL of the image associated with this option"""
  imageUrl: URL!

  """Unique identifier for the reward Item Id."""
  rewardItemId: UUID

  """Reward amount for the prediction option ."""
  rewardItemAmount: NonNegativeInt

  """ImagePrediction option localized data"""
  localizedData: [LiveLikeImagePredictionOptionLocalizedInput!]
}

"""Represents an image prediction followup widget."""
type LiveLikeImagePredictionFollowUp implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the image prediction."""
  id: UUID!

  """Client identifier associated with this prediction."""
  clientId: NonEmptyString!

  """Program identifier associated with this prediction."""
  programId: UUID!

  """Image Prediction identifier associated with this prediction followup."""
  imagePredictionId: UUID!

  """Optional Correct option id of the prediction."""
  correctOptionId: UUID

  """The question for the prediction to be made"""
  question: NonEmptyString!

  """List of options available for this prediction."""
  options: [LiveLikeImagePredictionOption!]!

  """Optional custom metadata for the widget."""
  customData: String

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Total number of unique users who interacted with the widget."""
  uniqueImpressionCount: NonNegativeInt

  """List of sponsor IDs associated with this Image Prediction."""
  sponsorIds: [UUID!]

  """Contains count-based metrics such as interactions."""
  reportCount: LiveLikeWidgetReportCount

  """Additional widget attributes in key-value format."""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """Information about the user that created the widget."""
  createdBy: LiveLikeWidgetCreator!

  """The ISO8601 DateTime when the widget stops accepting interactions."""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds."""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive."""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling."""
  publishDelay: Duration!

  """Program-scheduled datetime when the prediction is expected to appear."""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created."""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget."""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published."""
  publishedAt: DateTimeISO
}

input LiveLikeImagePredictionFollowUpCreateInput {
  """ID of the text prediction to create the follow up prediction."""
  imagePredictionId: UUID!

  """
  ID of the correct text prediction option to create the followup prediction.
  """
  correctOptionId: NonEmptyString

  """
  Links the sponsors with this Text Prediction. Note that only valid sponsor_ids will be linked to a Text Prediction.
  """
  sponsorIds: [UUID!]
}

input LiveLikeImagePredictionLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!
}

""" Represents a option in a image prediction. Includes correctness, user response count, and localization metadata.
"""
type LiveLikeImagePredictionOption implements LiveLikeNode {
  """Unique identifier for the image option."""
  id: UUID!

  """Description of the image prediction option."""
  description: String!

  """Indicates whether this option is the correct answer"""
  isCorrect: Boolean!

  """URL of the image associated with this option"""
  imageUrl: URL!

  """Unique identifier for the reward Item Id."""
  rewardItemId: UUID

  """Number of users who selected this option."""
  voteCount: NonNegativeInt!

  """Reward amount for the prediction option ."""
  rewardItemAmount: NonNegativeInt

  """List of all earned rewards"""
  earnableRewards: [LiveLikeReward!]

  """List of fields in this object that support translation"""
  translatableFields: [String!]
}

input LiveLikeImagePredictionOptionLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """Description of the option"""
  description: NonEmptyString!
}

type LiveLikeImagePredictionVote implements LiveLikeWidgetInteractionBase {
  """Unique ID of the image prediction vote"""
  id: UUID!

  """ID of the profile associated with the image prediction vote"""
  profileId: UUID!

  """ID of the widget associated with the image prediction vote"""
  widgetId: UUID!

  """Kind of the widget Interaction"""
  widgetKind: LiveLikeWidgetInteractionEnum!

  """Image Prediction widget associated with the image prediction vote"""
  widget: LiveLikeImagePrediction!

  """Timestamp when the widget was created."""
  createdAt: String!

  """Rewards associated with the image prediction vote"""
  rewards: [LiveLikeReward!]

  """Vote option associated with the image prediction vote"""
  optionId: UUID!

  """Claim token for the image prediction Vote"""
  claimToken: JWT!

  """Leaderboard rewards associated with the image prediction vote"""
  leaderboardRewards: [LiveLikeLeaderboardReward!]
}

input LiveLikeImagePredictionVoteCreateInput {
  widgetId: UUID!
  optionId: UUID!
}

input LiveLikeImagePredictionVoteUpdateInput {
  id: UUID!
  widgetId: UUID!
  optionId: UUID!
}

"""Represents an image quiz widget."""
type LiveLikeImageQuiz implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the image quiz."""
  id: UUID!

  """Client identifier associated with this quiz."""
  clientId: NonEmptyString!

  """Program identifier associated with this quiz."""
  programId: UUID!

  """The question for the quiz to be made"""
  question: NonEmptyString!

  """List of choices available for this quiz."""
  choices: [LiveLikeImageQuizChoice!]!

  """Optional custom metadata for the widget."""
  customData: String

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Total number of unique users who interacted with the widget."""
  uniqueImpressionCount: NonNegativeInt

  """List of sponsor IDs associated with this Image Quiz."""
  sponsorIds: [UUID!]

  """Contains count-based metrics such as interactions."""
  reportCount: LiveLikeWidgetReportCount

  """Additional widget attributes in key-value format."""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """Information about the user that created the widget."""
  createdBy: LiveLikeWidgetCreator!

  """The ISO8601 DateTime when the widget stops accepting interactions."""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds."""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive."""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling."""
  publishDelay: Duration!

  """Program-scheduled datetime when the quiz is expected to appear."""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created."""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget."""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published."""
  publishedAt: DateTimeISO
}

type LiveLikeImageQuizAnswer implements LiveLikeWidgetInteractionBase {
  """Unique identifier of the image quiz answer."""
  id: UUID!

  """ID of the profile who submitted the answer."""
  profileId: UUID!

  """ID of the widget instance this answer belongs to."""
  widgetId: UUID!

  """Type of widget interaction."""
  widgetKind: LiveLikeWidgetInteractionEnum!

  """The image quiz widget associated with this answer."""
  widget: LiveLikeImageQuiz!

  """Timestamp when the answer was created."""
  createdAt: String!

  """List of rewards granted for this answer."""
  rewards: [LiveLikeReward!]

  """List of leaderboard rewards associated with this answer."""
  leaderboardRewards: [LiveLikeLeaderboardReward!]

  """Identifier of the choice selected by the user."""
  choiceId: UUID!
}

input LiveLikeImageQuizAnswerCreateInput {
  """ID of the widget instance for which the answer is submitted."""
  widgetId: UUID!

  """ID of the choice selected by the user."""
  choiceId: UUID!
}

input LiveLikeImageQuizAnswerUpdateInput {
  """ID identifier of the image quiz answer to update."""
  id: UUID!

  """ID of the widget instance for which the answer is submitted."""
  widgetId: UUID!

  """ID of the choice selected by the user."""
  choiceId: UUID!
}

""" Represents a choice in a image quiz. Includes correctness, user response count, and localization metadata.
"""
type LiveLikeImageQuizChoice implements LiveLikeNode {
  """Unique identifier for the choice."""
  id: UUID!

  """Description of the choice."""
  description: String!

  """Indicates whether this choice is the correct answer"""
  isCorrect: Boolean!

  """URL of the image associated with this choice"""
  imageUrl: URL!

  """Number of users who selected this choice."""
  answerCount: NonNegativeInt!

  """List of fields in this object that support translation"""
  translatableFields: [String!]
}

input LiveLikeImageQuizChoiceLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """Description of the choice"""
  description: NonEmptyString!
}

"""Represents a choice option for a image quiz."""
input LiveLikeImageQuizCreateChoiceInput {
  """Description of the choice."""
  description: NonEmptyString!

  """Indicates whether this choice is the correct answer"""
  isCorrect: Boolean!

  """URL of the image associated with this choice"""
  imageUrl: URL!

  """ImageQuiz choice localized data"""
  localizedData: [LiveLikeImageQuizChoiceLocalizedInput!]
}

input LiveLikeImageQuizCreateInput {
  """ID of the program to create the prediction for"""
  programId: UUID!

  """A free-form field used for custom behaviors"""
  customData: NonEmptyString

  """ The prompt or question for the prediction to be made """
  question: NonEmptyString!

  """ List of choices for this quiz"""
  choices: [LiveLikeImageQuizCreateChoiceInput!]!

  """A iso8601 duration hint for when a Widget should be timed out """
  timeout: Duration

  """ The ISO8601 DateTime that the widget will stop accepting interactions 
  """
  interactiveUntil: DateTimeISO

  """ Video playback time in milliseconds """
  playbackTimeMs: NonNegativeInt

  """ An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """ Links the sponsors with this Image Quiz. Note that only valid sponsor_ids will be linked to a Image Quiz.
  """
  sponsorIds: [UUID!]

  """ImageQuiz localized data"""
  localizedData: [LiveLikeImageQuizLocalizedInput!]
}

input LiveLikeImageQuizLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!
}

input LiveLikeIncomingProfileRelationshipInput {
  relationshipTypeKey: NonEmptyString
  fromProfileId: UUID
  since: DateTimeISO
  until: DateTimeISO
}

type LiveLikeKeyValuePair {
  key: String!
  value: String!
}

input LiveLikeKeyValuePairInput {
  key: String!
  value: String!
}

type LiveLikeLeaderboard implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  name: NonEmptyString!
  isLocked: Boolean!
  rewardItemId: UUID!
  rewardItem: LiveLikeRewardItem
}

type LiveLikeLeaderboardCollection implements LiveLikeConnection {
  edges: [LiveLikeLeaderboardEdge!]
  page: LiveLikePage!
}

input LiveLikeLeaderboardCreateInput {
  clientId: NonEmptyString!
  name: NonEmptyString!
  rewardItemId: UUID!
  isLocked: Boolean
  attributes: [LiveLikeKeyValuePairInput!]
}

type LiveLikeLeaderboardEdge implements LiveLikeEdge {
  node: LiveLikeLeaderboard!
  cursor: String
}

input LiveLikeLeaderboardEntriesGetInput {
  leaderboardId: UUID!
  page: LiveLikePaginationOffsetInput
}

type LiveLikeLeaderboardEntry {
  score: PositiveInt!
  rank: PositiveInt!
  percentileRank: NonNegativeFloat!
  profileId: UUID!
  profileNickname: NonEmptyString!
}

type LiveLikeLeaderboardEntryCollection {
  edges: [LiveLikeLeaderboardEntryEdge!]
  page: LiveLikePageOffset!
}

type LiveLikeLeaderboardEntryEdge {
  node: LiveLikeLeaderboardEntry!
  cursor: String
}

input LiveLikeLeaderboardEntryGetInput {
  leaderboardId: UUID!
  profileId: UUID!
}

input LiveLikeLeaderboardProgramLinkInput {
  leaderboardId: UUID!
  programId: UUID!
}

type LiveLikeLeaderboardReward {
  leaderboardId: UUID!
  leaderboardName: NonEmptyString!
  rewardItemId: UUID!
  rewardAction: LiveLikeRewardActionEnum!
  rewardItemAmount: PositiveInt!
  rewardItemName: NonEmptyString!
  newRank: NonNegativeInt!
  newPercentileRank: NonEmptyString!
  newScore: NonNegativeFloat!
}

input LiveLikeLeaderboardsGetInput {
  clientId: NonEmptyString!
  programIds: [UUID!]
  page: PositiveInt
}

input LiveLikeLeaderboardUpdateInput {
  id: UUID!
  name: NonEmptyString
  isLocked: Boolean
  attributes: [LiveLikeKeyValuePairInput!]
}

input LiveLikeLinkRewardTableWithProgramInput {
  programId: UUID!
  rewardTableId: UUID!
}

interface LiveLikeNode {
  id: UUID!
}

enum LiveLikeOrderEnum {
  ASC
  DESC
}

input LiveLikeOutgoingProfileRelationshipInput {
  relationshipTypeKey: NonEmptyString
  toProfileId: UUID
  since: DateTimeISO
  until: DateTimeISO
}

type LiveLikePage {
  startCursor: String
  endCursor: String
  next: PositiveInt
  previous: PositiveInt
  count: NonNegativeInt
}

type LiveLikePageOffset {
  count: NonNegativeInt
  next: LiveLikePaginationOffset
  previous: LiveLikePaginationOffset
}

type LiveLikePaginationOffset {
  offset: NonNegativeInt
  limit: NonNegativeInt
}

input LiveLikePaginationOffsetInput {
  offset: NonNegativeInt
  limit: NonNegativeInt
}

type LiveLikePermission implements LiveLikeNode {
  id: UUID!
  key: NonEmptyString!
  name: NonEmptyString!
  description: String!
  createdAt: DateTimeISO!
}

type LiveLikePermissionEdge implements LiveLikeEdge {
  node: LiveLikePermission!
  cursor: String
}

type LiveLikePermissions implements LiveLikeConnection {
  edges: [LiveLikePermissionEdge]
  page: LiveLikePage!
}

enum LiveLikePollInteractionEnum {
  TEXT_POLL
  IMAGE_POLL
}

"""
DEPRECATED: Use widget specific one 
(TextPollVoteCreateInput, ImagePollVoteCreateInput)
"""
input LiveLikePollVoteCreateInput {
  kind: LiveLikePollInteractionEnum!
  widgetId: UUID!
  optionId: UUID!
}

"""
DEPRECATED: Use widget specific one 
(TextPollVoteUpdateInput, ImagePollVoteUpdateInput)
"""
input LiveLikePollVoteUpdateInput {
  id: UUID!
  kind: LiveLikePollInteractionEnum!
  widgetId: UUID!
  optionId: UUID!
}

type LiveLikeProfile implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString
  customId: NonEmptyString
  nickname: NonEmptyString!
  customData: String
  createdAt: NonEmptyString!
  incomingProfileRelationships(input: LiveLikeIncomingProfileRelationshipInput, order: LiveLikeProfileRelationshipOrderInput): LiveLikeProfileRelationshipCollection
  outgoingProfileRelationships(input: LiveLikeOutgoingProfileRelationshipInput, order: LiveLikeProfileRelationshipOrderInput): LiveLikeProfileRelationshipCollection
  widgetsInteractions(input: [LiveLikeWidgetInteractionsInput!]!): [LiveLikeWidgetInteractions!]
  rewardBalance(input: LiveLikeRewardBalanceGetInput!): LiveLikeRewardItemBalance
  rewardBalances(input: LiveLikeRewardBalancesGetInput): LiveLikeRewardItemBalanceCollection
  badges: LiveLikeEarnedBadgeCollection
  badgeProgress(badgeId: UUID!): [LiveLikeBadgeRewardProgressCollection!]
  quests(input: LiveLikeUserQuestsInput): LiveLikeUserQuestCollection
}

type LiveLikeProfileAuth implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  customId: NonEmptyString
  accessToken: JWT!
  nickname: NonEmptyString!
  createdAt: NonEmptyString!
}

input LiveLikeProfileByCustomIdCreateInput {
  clientId: NonEmptyString!
  customId: NonEmptyString!
  nickname: NonEmptyString
}

input LiveLikeProfileCreateInput {
  clientId: NonEmptyString!
  nickname: NonEmptyString
}

input LiveLikeProfileGetByCustomIdInput {
  clientId: NonEmptyString!
  customId: NonEmptyString!
}

type LiveLikeProfileRelationship implements LiveLikeNode {
  id: UUID!
  relationshipType: LiveLikeProfileRelationshipType!
  fromProfile: LiveLikeProfile!
  toProfile: LiveLikeProfile!
  createdAt: DateTimeISO!
}

type LiveLikeProfileRelationshipCollection implements LiveLikeConnection {
  edges: [LiveLikeProfileRelationshipEdge!]
  page: LiveLikePage!
}

input LiveLikeProfileRelationshipCreateInput {
  relationshipTypeKey: NonEmptyString!
  fromProfileId: UUID!
  toProfileId: UUID!
}

type LiveLikeProfileRelationshipEdge implements LiveLikeEdge {
  node: LiveLikeProfileRelationship!
  cursor: String
}

input LiveLikeProfileRelationshipInput {
  clientId: NonEmptyString!
  relationshipTypeKey: NonEmptyString
  fromProfileId: UUID
  toProfileId: UUID
  since: DateTimeISO
  until: DateTimeISO
}

enum LiveLikeProfileRelationshipOrderField {
  CREATED_AT
}

input LiveLikeProfileRelationshipOrderInput {
  field: LiveLikeProfileRelationshipOrderField!
  order: LiveLikeOrderEnum
}

type LiveLikeProfileRelationshipType implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  name: NonEmptyString!
  key: NonEmptyString!
  createdAt: DateTimeISO!
}

type LiveLikeProfileRelationshipTypeCollection implements LiveLikeConnection {
  edges: [LiveLikeProfileRelationshipTypeEdge!]
  page: LiveLikePage!
}

input LiveLikeProfileRelationshipTypeCreateInput {
  clientId: NonEmptyString!
  name: NonEmptyString!
  key: NonEmptyString!
}

type LiveLikeProfileRelationshipTypeEdge implements LiveLikeEdge {
  node: LiveLikeProfileRelationshipType!
  cursor: String
}

input LiveLikeProfileRelationshipTypesInput {
  clientId: NonEmptyString!
  key: NonEmptyString
}

input LiveLikeProfileUpdateInput {
  id: UUID!
  nickname: NonEmptyString
  customData: NonEmptyString
}

type LiveLikeProgram implements LiveLikeNode {
  id: UUID!

  """The unique identifier of the app to create the program in"""
  clientId: NonEmptyString!

  """The human-readable title of the program"""
  title: NonEmptyString!
  widgetsEnabled: Boolean!
  status: LiveLikeProgramStatusEnum!

  """Associate this Program with an ID in another system"""
  customId: NonEmptyString

  """
  List of sponsors to link with the program. Note that only valid sponsor_ids will be linked to a program.
  """
  sponsorIds: [UUID!]

  """
  The date and time the program is scheduled to begin in ISO format compliant with RFC 3339
  """
  scheduledAt: DateTimeISO!

  """
  The date and time the program started in ISO format compliant with RFC 3339
  """
  startedAt: DateTimeISO

  """
  The date and time the program stopped in ISO format compliant with RFC 3339
  """
  stoppedAt: DateTimeISO

  """The date and time the program was created in ISO format"""
  createdAt: NonEmptyString!
  widgets(input: LiveLikeWidgetGetInput, order: LiveLikeWidgetOrderInput): LiveLikeWidgetCollection
}

type LiveLikeProgramBan implements LiveLikeNode {
  id: UUID!
  programId: UUID!
  clientId: NonEmptyString!
  comment: NonEmptyString!
  bannedProfile: LiveLikeProfile!
  bannedByProfile: LiveLikeProfile!
  expiringAt: DateTimeISO
  createdAt: DateTimeISO!
}

type LiveLikeProgramBanCollection {
  edges: [LiveLikeProgramBanEdge!]
  page: LiveLikePage!
}

type LiveLikeProgramBanEdge {
  node: LiveLikeProgramBan!
  cursor: String
}

input LiveLikeProgramBanInput {
  programId: UUID!
  bannedProfileId: UUID!
  comment: NonEmptyString!
  expiringAt: DateTimeISO
}

input LiveLikeProgramBansInput {
  programId: UUID
  bannedProfileId: UUID
  bannedByProfileId: UUID
  page: PositiveInt
}

type LiveLikeProgramConnection implements LiveLikeConnection {
  edges: [LiveLikeProgramEdge]
  page: LiveLikePage!
}

input LiveLikeProgramCreateInput {
  clientId: NonEmptyString!

  """Associate this Program with an ID in another system"""
  customId: NonEmptyString

  """The human-readable title of the program"""
  title: NonEmptyString!

  """
  The date and time the program is scheduled to begin in ISO format compliant with RFC 3339
  """
  scheduledAt: DateTimeISO!

  """
  List of sponsors to link with the program. Note that only valid sponsorId's will be linked to a program.
  """
  sponsorIds: [UUID!]

  """Program localized data"""
  localizedData: [LiveLikeProgramLocalizedInput!]
}

input LiveLikeProgramDeleteByCustomIdInput {
  clientId: NonEmptyString!

  """Associates this Program with an ID in another system"""
  customId: NonEmptyString!
}

type LiveLikeProgramEdge implements LiveLikeEdge {
  node: LiveLikeProgram!
  cursor: String
}

input LiveLikeProgramGetByCustomIdInput {
  clientId: NonEmptyString!

  """Associates this Program with an ID in another system"""
  customId: NonEmptyString!
}

input LiveLikeProgramLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """Localized title of the program"""
  title: NonEmptyString!
}

type LiveLikeProgramSchedule implements LiveLikeNode {
  id: UUID!
  status: LiveLikeProgramStatusEnum!
  startedAt: DateTimeISO
  stoppedAt: DateTimeISO
}

input LiveLikeProgramsGetInput {
  clientId: NonEmptyString!
  page: PositiveInt
}

enum LiveLikeProgramStatusEnum {
  FUTURE
  LIVE
  PAST
}

input LiveLikeProgramUpdateByCustomIdInput {
  clientId: NonEmptyString!

  """Associate this Program with an ID in another system"""
  customId: NonEmptyString!

  """The human-readable title of the program"""
  title: NonEmptyString

  """
  The date and time the program is scheduled to begin in ISO format compliant with RFC 3339
  """
  scheduledAt: DateTimeISO

  """
  List of sponsors to link with the program. Note that only valid sponsorId's will be linked to a program.
  """
  sponsorIds: [UUID!]

  """Program localized data"""
  localizedData: [LiveLikeProgramLocalizedInput!]
}

input LiveLikeProgramUpdateInput {
  id: UUID!

  """Associate this Program with an ID in another system"""
  customId: NonEmptyString

  """The human-readable title of the program"""
  title: NonEmptyString

  """
  The date and time the program is scheduled to begin in ISO format compliant with RFC 3339
  """
  scheduledAt: DateTimeISO

  """
  List of sponsors to link with the program. Note that only valid sponsorId's will be linked to a program.
  """
  sponsorIds: [UUID!]

  """Program localized data"""
  localizedData: [LiveLikeProgramLocalizedInput!]
}

type LiveLikeQuest implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  name: NonEmptyString!
  description: String!
  status: LiveLikeQuestStatusEnum!
  questTasks: [LiveLikeQuestTask!]
  timeout: String
  questRewards: [LiveLikeQuestReward!]
  attributes: [LiveLikeKeyValuePair!]
  createdAt: DateTimeISO!
  startedAt: DateTimeISO
  stoppedAt: DateTimeISO
}

type LiveLikeQuestCollection implements LiveLikeConnection {
  edges: [LiveLikeQuestEdge!]
  page: LiveLikePage!
}

type LiveLikeQuestEdge implements LiveLikeEdge {
  node: LiveLikeQuest!
  cursor: String
}

input LiveLikeQuestInput {
  clientId: NonEmptyString!
  name: NonEmptyString!
  description: String!
  timeout: String
  startedAt: DateTimeISO
  stoppedAt: DateTimeISO
}

type LiveLikeQuestReward implements LiveLikeNode {
  id: UUID!
  questId: UUID!
  rewardItemId: UUID!
  rewardItemAmount: PositiveInt!
  rewardItemName: NonEmptyString!
}

enum LiveLikeQuestStatusEnum {
  ACTIVE
  NOT_STARTED
  EXPIRED
}

type LiveLikeQuestTask implements LiveLikeNode {
  id: UUID!
  name: NonEmptyString!
  questId: UUID!
  description: String!
  targetValue: PositiveInt!
  defaultProgressIncrement: NonNegativeInt!
  attributes: [LiveLikeKeyValuePair!]
  createdAt: DateTimeISO!
}

type LiveLikeReaction implements LiveLikeNode {
  id: UUID!
  count: NonNegativeInt!
  userReactionId: UUID!
}

type LiveLikeReactionPack implements LiveLikeNode {
  id: UUID!
  name: NonEmptyString!
  emojis: [LiveLikeEmoji]
}

type LiveLikeReactionPackCollection implements LiveLikeConnection {
  edges: [LiveLikeReactionPackEdge]
  page: LiveLikePage!
}

type LiveLikeReactionPackEdge implements LiveLikeEdge {
  node: LiveLikeReactionPack!
  cursor: String
}

input LiveLikeReactionPacksGetInput {
  clientId: NonEmptyString!
  page: PositiveInt
}

type LiveLikeReactions {
  reactions: [LiveLikeReaction!]
  targetId: NonEmptyString!
}

type LiveLikeReactionSpace implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  targetGroupId: NonEmptyString!
  name: NonEmptyString
  reactionPackIds: [UUID!]
  reactionSpaceChannel: NonEmptyString
  createdBy: UUID!
}

type LiveLikeReactionSpaceCollection implements LiveLikeConnection {
  edges: [LiveLikeReactionSpaceEdge]
  page: LiveLikePage!
}

type LiveLikeReactionSpaceCount {
  reactionSpaceId: UUID!
  targetGroupId: NonEmptyString!
  reactionsCount: NonNegativeInt!
  emojiCounts: [LiveLikeEmojiCount!]
}

input LiveLikeReactionSpaceCreateInput {
  clientId: NonEmptyString!
  targetGroupId: NonEmptyString!
  name: NonEmptyString
  reactionPackIds: [UUID!]
}

input LiveLikeReactionSpaceDeleteInput {
  id: UUID!
  clientId: NonEmptyString!
}

type LiveLikeReactionSpaceEdge implements LiveLikeEdge {
  node: LiveLikeReactionSpace!
  cursor: String
}

input LiveLikeReactionSpaceGetInput {
  clientId: NonEmptyString!
  reactionSpaceId: UUID
  targetGroupId: NonEmptyString
  page: PositiveInt
}

type LiveLikeReactionSpacePatch {
  name: NonEmptyString
  reactionPackIds: [UUID!]!
}

input LiveLikeReactionSpacesCountInput {
  clientId: NonEmptyString!
  reactionSpaceIds: [UUID!]!
}

input LiveLikeReactionSpaceUpdateInput {
  id: UUID!
  name: NonEmptyString
  reactionPackIds: [UUID!]!
}

type LiveLikeResource implements LiveLikeNode {
  id: UUID!
  kind: LiveLikeResourceKindEnum!
  name: NonEmptyString!
  description: NonEmptyString!
  createdAt: DateTimeISO!
}

enum LiveLikeResourceKindEnum {
  ALERT
  APPLICATION
  CHAT_ROOM
  CHEER_METER
  COMMENT_BOARD
  EMOJI_POLL
  EMOJI_SLIDER
  IMAGE_NUMBER_PREDICTION
  IMAGE_NUMBER_PREDICTION_FOLLOW_UP
  IMAGE_POLL
  IMAGE_PREDICTION
  IMAGE_PREDICTION_FOLLOW_UP
  IMAGE_QUIZ
  PROFILE
  PROGRAM
  RICH_POST
  SOCIAL_EMBED
  TEXT_ASK
  TEXT_POLL
  TEXT_PREDICTION
  TEXT_PREDICTION_FOLLOW_UP
  TEXT_QUIZ
  TWITTER_SPOTLIGHT
  VIDEO_ALERT
}

"""Represents a reward earned by a user for performing a specific action."""
type LiveLikeReward {
  """Unique identifier of the reward item."""
  rewardItemId: UUID!

  """The action for which this reward is given."""
  rewardAction: LiveLikeRewardActionEnum!

  """The amount or value associated with the reward item."""
  rewardItemAmount: NonNegativeInt!

  """The name or label of the reward item."""
  rewardItemName: NonEmptyString!
}

type LiveLikeRewardAction implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  programId: UUID!
  profileId: UUID!
  profileNickname: NonEmptyString!
  rewardActionKey: NonEmptyString!
  rewards: [LiveLikeRewardActionItem!]
  code: NonEmptyString
  attributes: [LiveLikeKeyValuePair!]
  createdAt: NonEmptyString!
}

input LiveLikeRewardActionCreateInput {
  programId: UUID!
  profileId: UUID!
  rewardActionKey: NonEmptyString!
  code: NonEmptyString
}

enum LiveLikeRewardActionEnum {
  ASK_REPLIED
  POLL_VOTED
  PREDICTION_CORRECT
  PREDICTION_MADE
  QUIZ_ANSWERED
  QUIZ_CORRECT
}

type LiveLikeRewardActionItem implements LiveLikeNode {
  id: UUID!
  name: NonEmptyString!
  amount: NonNegativeInt!
}

type LiveLikeRewardATableActionChoice {
  action: String!
  actionDisplay: NonEmptyString!
}

input LiveLikeRewardBalanceGetInput {
  rewardItemId: UUID!
}

input LiveLikeRewardBalancesGetInput {
  rewardItemIds: [UUID!]!
}

type LiveLikeRewardItem implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString
  name: NonEmptyString!
  images: [LiveLikeRewardItemImage!]
  attributes: [LiveLikeKeyValuePair!]
  rewardItemPoints: NonNegativeInt
  prizeoutPoints: NonNegativeInt
  prizeoutConversionRate: NonNegativeInt
  prizeoutStatus: Boolean
}

type LiveLikeRewardItemBalance {
  rewardItemId: UUID!
  rewardItemName: NonEmptyString!
  rewardItemBalance: NonNegativeInt!
  profileId: UUID!
}

type LiveLikeRewardItemBalanceCollection {
  edges: [LiveLikeRewardItemBalanceEdge!]
  page: LiveLikePage!
}

type LiveLikeRewardItemBalanceEdge {
  node: LiveLikeRewardItemBalance!
  cursor: String
}

type LiveLikeRewardItemCollection implements LiveLikeConnection {
  edges: [LiveLikeRewardItemEdge!]
  page: LiveLikePage!
}

input LiveLikeRewardItemCreateInput {
  clientId: NonEmptyString!
  name: NonEmptyString!
  attributes: [LiveLikeKeyValuePairInput!]
}

type LiveLikeRewardItemEdge implements LiveLikeEdge {
  node: LiveLikeRewardItem!
  cursor: String
}

type LiveLikeRewardItemImage implements LiveLikeNode {
  id: UUID!
  imageUrl: URL!
  name: String
  mimeType: String
}

"""
Represents a transaction made on a RewardItem, such as credits or debits applied to a user's reward item balance.
"""
type LiveLikeRewardItemTransaction implements LiveLikeNode {
  """Unique identifier of the reward item transaction"""
  id: UUID!

  """The new balance of the reward item transaction"""
  newBalance: NonNegativeInt!

  """The user's prizeout balance of reward item"""
  prizeoutBalance: NonNegativeInt

  """The reason of transaction """
  reason: NonEmptyString!

  """Optional description for the reward item transaction."""
  description: NonEmptyString

  """Optional custom metadata for the reward item transaction."""
  customData: NonEmptyString

  """Additional attributes stored as key-value pairs."""
  attributes: [LiveLikeKeyValuePair!]

  """UUID of the user that performed this transaction."""
  transactedById: UUID!

  """Nickname or label of the user who performed this transaction"""
  transactedByNickname: NonEmptyString!

  """Timestamp when the transaction was created, in ISO 8601 format."""
  createdAt: NonEmptyString!
}

"""Input type for crediting or debiting a RewardItem."""
input LiveLikeRewardItemTransactionInput {
  """ID of the profile associated with the transaction"""
  profileId: UUID!

  """ID of the reward item being credited or debited"""
  rewardItemId: UUID!

  """Amount to credit or debit. Must be a positive integer."""
  rewardItemAmount: PositiveInt!

  """Optional reason for the transaction"""
  reason: NonEmptyString

  """Optional description providing the context of the transaction"""
  description: NonEmptyString

  """Optional custom metadata related to the transaction, in string format"""
  customData: NonEmptyString

  """Optional additional attributes as key-value pairs"""
  attributes: [LiveLikeKeyValuePairInput!]
}

type LiveLikeRewardTable implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  name: NonEmptyString!
  actionChoices: [LiveLikeRewardATableActionChoice!]!
  entries: [LiveLikeRewardTableEntry!]!
}

type LiveLikeRewardTableCollection implements LiveLikeConnection {
  edges: [LiveLikeRewardTableEdge!]
  page: LiveLikePage!
}

input LiveLikeRewardTableCreateInput {
  clientId: NonEmptyString!
  name: NonEmptyString!
  entries: [LiveLikeRewardTableEntryInput!]!
}

type LiveLikeRewardTableEdge implements LiveLikeEdge {
  node: LiveLikeRewardTable!
  cursor: String
}

type LiveLikeRewardTableEntry {
  id: UUID!
  action: NonEmptyString!
  actionDisplay: NonEmptyString!
  rewardItemAmount: PositiveInt!
  rewardItem: LiveLikeRewardItem!
}

input LiveLikeRewardTableEntryCreateInput {
  rewardTableId: UUID!
  rewardItemId: UUID!
  rewardItemAmount: PositiveInt!
  action: NonEmptyString!
}

input LiveLikeRewardTableEntryDeleteInput {
  id: UUID!
  entryId: UUID!
}

input LiveLikeRewardTableEntryGetInput {
  id: UUID!
  entryId: UUID!
}

input LiveLikeRewardTableEntryInput {
  rewardItemId: UUID!
  rewardItemAmount: PositiveInt!
  action: NonEmptyString!
}

input LiveLikeRewardTablesGetInput {
  clientId: NonEmptyString!
  page: PositiveInt
}

input LiveLikeRewardTableUpdateInput {
  id: UUID!
  name: NonEmptyString
  entries: [LiveLikeRewardTableEntryInput!]
}

type LiveLikeRichPost implements LiveLikeWidgetBase & LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!

  """Rich Post related program id"""
  programId: UUID!
  kind: LiveLikeWidgetKindEnum!

  """Title of the post"""
  title: String

  """HTML content of the post"""
  content: String
  customData: String
  createdBy: LiveLikeWidgetCreator!
  status: LiveLikeWidgetStatusEnum!
  timeout: Duration!

  """Whether pubnub is enabled (if applicable)."""
  pubnubEnabled: Boolean!
  uniqueImpressionCount: NonNegativeInt

  """The ISO8601 Date that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePair!]
  filteredTitle: String
  filteredContent: String
  contentFilter: [String!]

  """List the sponsors ids with this RichPost."""
  sponsorIds: [UUID!]

  """
  Delay (ISO8601) before the widget is published after scheduling (if applicable).
  """
  publishDelay: Duration!

  """
  Program-scheduled datetime when the widget is expected to appear (if applicable).
  """
  programDateTime: DateTimeISO

  """Report count information"""
  reportCount: LiveLikeWidgetReportCount
  createdAt: DateTimeISO!
  scheduledAt: DateTimeISO
  publishedAt: DateTimeISO
}

input LiveLikeRichPostCreateInput {
  """The program to create the rich post inside of"""
  programId: UUID!

  """Title of the post"""
  title: NonEmptyString

  """HTML content of the post"""
  content: NonEmptyString!

  """A free-form field used for custom behaviors"""
  customData: String

  """A iso8601 duration hint for when a Widget should be timed out"""
  timeout: Duration

  """The ISO8601 Date that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this Text Poll. Note that only valid sponsor_ids will be linked to a Text Poll.
  """
  sponsorIds: [UUID!]

  """RichPost localized data"""
  localizedData: [LiveLikeRichPostLocalizedInput!]
}

input LiveLikeRichPostLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """Title of the post"""
  title: NonEmptyString

  """HTML content of the post"""
  content: NonEmptyString!
}

type LiveLikeRole implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  key: NonEmptyString!
  name: NonEmptyString!
  description: String!
  isActive: Boolean!
  createdAt: DateTimeISO!
  permissions: [LiveLikePermission!]!
}

type LiveLikeRoleAssignment implements LiveLikeNode {
  id: UUID!
  profile: LiveLikeProfile
  role: LiveLikeRole
  scope: LiveLikeScope
  createdAt: DateTimeISO!
}

type LiveLikeRoleAssignmentConnection implements LiveLikeConnection {
  edges: [LiveLikeRoleAssignmentEdge!]
  page: LiveLikePage!
}

input LiveLikeRoleAssignmentCreateInput {
  """id of the profile to assign the role to"""
  profileId: UUID!

  """key of the role to assign to the profile"""
  roleKey: NonEmptyString!

  """key of the scope to assign the role to"""
  resourceKey: NonEmptyString!

  """kind of the scope to assign the role to"""
  resourceKind: LiveLikeResourceKindEnum!
}

type LiveLikeRoleAssignmentEdge implements LiveLikeEdge {
  node: LiveLikeRoleAssignment!
  cursor: String
}

input LiveLikeRoleAssignmentsGetInput {
  profileId: NonEmptyString
  profileCustomId: NonEmptyString
  page: PositiveInt
}

type LiveLikeRoleConnection implements LiveLikeConnection {
  edges: [LiveLikeRoleEdge!]
  page: LiveLikePage!
}

input LiveLikeRoleCreateInput {
  """key of the role to be created"""
  key: NonEmptyString!

  """name of the role to be created"""
  name: NonEmptyString!

  """key of the role template to add permissions from"""
  roleTemplateKey: NonEmptyString

  """Array of permissionIds to add to the role"""
  permissionIds: [UUID!]

  """Array of permissionKeys to add to the role"""
  permissionKeys: [NonEmptyString!]
}

type LiveLikeRoleEdge implements LiveLikeEdge {
  node: LiveLikeRole!
  cursor: String
}

input LiveLikeRolesGetInput {
  clientId: NonEmptyString!
  page: PositiveInt
}

type LiveLikeScope implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  resourceKey: NonEmptyString!
  resource: LiveLikeResource!
  createdAt: DateTimeISO!
}

type LiveLikeSocialEmbed implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the widget"""
  id: UUID!

  """Client identifier associated with this widget"""
  clientId: NonEmptyString!

  """Program identifier associated with this widget"""
  programId: UUID!

  """Information about the user that created the widget"""
  createdBy: LiveLikeWidgetCreator!

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Optional custom metadata for the widget"""
  customData: String

  """Additional widget attributes in key-value format"""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """List of sponsor IDs associated with this widget"""
  sponsorIds: [UUID!]

  """Total number of unique users who interacted with the widget"""
  uniqueImpressionCount: NonNegativeInt

  """Contains count-based metrics such as interactions"""
  reportCount: LiveLikeWidgetReportCount

  """ISO8601 DateTime when the widget stops accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive"""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling"""
  publishDelay: Duration!

  """Program-scheduled datetime when the widget is expected to appear"""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created"""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget"""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published"""
  publishedAt: DateTimeISO

  """comment of the social embed widget"""
  comment: NonEmptyString

  """social oEmbed item"""
  oEmbedItem: LiveLikeSocialEmbedItem
}

input LiveLikeSocialEmbedCreateInput {
  """ID of the program to create the widget"""
  programId: UUID!

  """free-form field used for custom behaviors"""
  customData: String

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this widget. 
  Note only valid sponsor ids will be linked to widget.
  """
  sponsorIds: [UUID!]

  """ISO8601 duration hint for when a widget should be timed out"""
  timeout: Duration

  """ISO8601 DateTime that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """comment of the social embed widget"""
  comment: NonEmptyString

  """oEmbed url of social embed item https://oembed.com/"""
  oEmbedUrl: URL!

  """Social embed localized data"""
  localizedData: [LiveLikeSocialEmbedLocalizedInput!]
}

type LiveLikeSocialEmbedItem implements LiveLikeNode {
  """Unique identifier of the social embed item"""
  id: UUID!

  """oEmbed url of social embed item https://oembed.com/"""
  oEmbedUrl: URL

  """oEmbed meta of social embed item https://oembed.com/"""
  oEmbedMeta: JSONObject
}

input LiveLikeSocialEmbedLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47 (RFC 5646) standard 
  """
  language: Locale!

  """comment of the social embed widget"""
  comment: NonEmptyString!
}

type LiveLikeTextPoll implements LiveLikeWidgetBase & LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  programId: UUID!
  kind: LiveLikeWidgetKindEnum!
  createdBy: LiveLikeWidgetCreator!
  userVote: LiveLikeWidgetInteraction @deprecated(reason: "Introduces cyclic dependency and TextPoll cache issue")
  createdAt: DateTimeISO!
  scheduledAt: DateTimeISO
  publishedAt: DateTimeISO
  customData: String
  filteredQuestion: String
  contentFilter: [String!]
  status: LiveLikeWidgetStatusEnum!
  pubnubEnabled: Boolean!
  uniqueImpressionCount: NonNegativeInt
  timeout: Duration!

  """The ISO8601 Date that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!

  """List of options for this prediction"""
  options: [LiveLikeTextPollOption!]!

  """List the sponsors ids with this Text Poll."""
  sponsorIds: [UUID!]

  """
  Delay (ISO8601) before the widget is published after scheduling (if applicable).
  """
  publishDelay: Duration!

  """
  Program-scheduled datetime when the widget is expected to appear (if applicable).
  """
  programDateTime: DateTimeISO

  """Report count information"""
  reportCount: LiveLikeWidgetReportCount
}

input LiveLikeTextPollCreateInput {
  """ID of the program to create the prediction for"""
  programId: UUID!

  """A free-form field used for custom behaviors"""
  customData: String

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!

  """List of options for this prediction, min 2 and max 4"""
  options: [LiveLikeTextPollCreateOptionInput!]!

  """A iso8601 duration hint for when a Widget should be timed out"""
  timeout: Duration

  """The ISO8601 DateTime that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this Text Poll. Note that only valid sponsor_ids will be linked to a Text Poll.
  """
  sponsorIds: [UUID!]

  """TextPoll localized data"""
  localizedData: [LiveLikeTextPollLocalizedInput!]
}

input LiveLikeTextPollCreateOptionInput {
  """Description of a poll option"""
  description: NonEmptyString!

  """TextPoll option localized data"""
  localizedData: [LiveLikeTextPollOptionLocalizedInput!]
}

input LiveLikeTextPollLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47 (RFC 5646) standard.
  """
  language: Locale!

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!
}

type LiveLikeTextPollOption implements LiveLikeNode {
  id: UUID!
  translatableFields: [String!]
  voteCount: Int
  description: String!
  filteredDescription: String
  contentFilter: [String!]
}

input LiveLikeTextPollOptionLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47 (RFC 5646) standard.
  """
  language: Locale!

  """Description of a poll option"""
  description: NonEmptyString!
}

type LiveLikeTextPollVote implements LiveLikeWidgetInteractionBase {
  id: UUID!

  """ID of the profile associated with the text poll vote"""
  profileId: UUID!

  """ID of the widget associated with the text poll vote"""
  widgetId: UUID!
  widgetKind: LiveLikeWidgetInteractionEnum!

  """Text poll widget associated with the text poll vote"""
  widget: LiveLikeTextPoll!
  createdAt: String!

  """Rewards associated with the text poll vote"""
  rewards: [LiveLikeReward!]

  """Leaderboard rewards associated with the text poll vote"""
  leaderboardRewards: [LiveLikeLeaderboardReward!]

  """Vote option associated with the text poll vote"""
  optionId: UUID!
}

input LiveLikeTextPollVoteCreateInput {
  widgetId: UUID!
  optionId: UUID!
}

input LiveLikeTextPollVoteUpdateInput {
  id: UUID!
  widgetId: UUID!
  optionId: UUID!
}

"""Represents an text prediction widget."""
type LiveLikeTextPrediction implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the text prediction."""
  id: UUID!

  """Client identifier associated with this prediction."""
  clientId: NonEmptyString!

  """Program identifier associated with this prediction."""
  programId: UUID!

  """The question for the prediction to be made"""
  question: NonEmptyString!

  """List of options available for this prediction."""
  options: [LiveLikeTextPredictionOption!]!

  """List of all follow ups available for this prediction."""
  followUps: [LiveLikeTextPredictionFollowUp!]!

  """Optional custom metadata for the widget."""
  customData: String

  """Optional confirmation message for the widget."""
  confirmationMessage: String

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Total number of unique users who interacted with the widget."""
  uniqueImpressionCount: NonNegativeInt

  """List of sponsor IDs associated with this Text Prediction."""
  sponsorIds: [UUID!]

  """Contains count-based metrics such as interactions."""
  reportCount: LiveLikeWidgetReportCount

  """Additional widget attributes in key-value format."""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """Information about the user that created the widget."""
  createdBy: LiveLikeWidgetCreator!

  """The ISO8601 DateTime when the widget stops accepting interactions."""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds."""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive."""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling."""
  publishDelay: Duration!

  """Program-scheduled datetime when the prediction is expected to appear."""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created."""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget."""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published."""
  publishedAt: DateTimeISO
}

input LiveLikeTextPredictionCreateInput {
  """ID of the program to create the prediction for"""
  programId: UUID!

  """A free-form field used for custom behaviors"""
  customData: NonEmptyString

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!

  """List of options for this prediction, min 2 and max 4"""
  options: [LiveLikeTextPredictionCreateOptionInput!]!

  """Optional confirmation message for the widget."""
  confirmationMessage: String

  """A iso8601 duration hint for when a Widget should be timed out"""
  timeout: Duration

  """The ISO8601 DateTime that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this Text Prediction. Note that only valid sponsor_ids will be linked to a Text Prediction.
  """
  sponsorIds: [UUID!]

  """TextPrediction localized data"""
  localizedData: [LiveLikeTextPredictionLocalizedInput!]
}

"""Represents a option for a text prediction."""
input LiveLikeTextPredictionCreateOptionInput {
  """Description of the prediction."""
  description: NonEmptyString!

  """Indicates whether this option is the correct option."""
  isCorrect: Boolean

  """Unique identifier for the reward Item Id."""
  rewardItemId: UUID

  """Reward amount for the prediction option ."""
  rewardItemAmount: NonNegativeInt

  """TextPrediction option localized data"""
  localizedData: [LiveLikeTextPredictionOptionLocalizedInput!]
}

"""Represents an text prediction followup."""
type LiveLikeTextPredictionFollowUp implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the text prediction followup."""
  id: UUID!

  """Client identifier associated with this prediction followup."""
  clientId: NonEmptyString!

  """Program identifier associated with this prediction."""
  programId: UUID!

  """Text Prediction identifier associated with this prediction followup."""
  textPredictionId: UUID!

  """Optional Correct option id of the prediction."""
  correctOptionId: UUID

  """The question for the prediction to be made"""
  question: NonEmptyString!

  """List of options available for this prediction."""
  options: [LiveLikeTextPredictionOption!]!

  """Optional custom metadata for the widget."""
  customData: String

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Total number of unique users who interacted with the widget."""
  uniqueImpressionCount: NonNegativeInt

  """List of sponsor IDs associated with this Text Prediction."""
  sponsorIds: [UUID!]

  """Contains count-based metrics such as interactions."""
  reportCount: LiveLikeWidgetReportCount

  """Additional widget attributes in key-value format."""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """Information about the user that created the widget."""
  createdBy: LiveLikeWidgetCreator!

  """The ISO8601 DateTime when the widget stops accepting interactions."""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds."""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive."""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling."""
  publishDelay: Duration!

  """Program-scheduled datetime when the prediction is expected to appear."""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created."""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget."""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published."""
  publishedAt: DateTimeISO
}

input LiveLikeTextPredictionFollowUpCreateInput {
  """ID of the text prediction to create the followup prediction for"""
  textPredictionId: UUID!

  """
  ID of the correct text prediction option to create the followup prediction for
  """
  correctOptionId: NonEmptyString

  """
  Links the sponsors with this Text Prediction. Note that only valid sponsor_ids will be linked to a Text Prediction.
  """
  sponsorIds: [UUID!]
}

input LiveLikeTextPredictionLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!
}

""" Represents a option in a text prediction. Includes correctness."""
type LiveLikeTextPredictionOption implements LiveLikeNode {
  """Unique identifier for the option."""
  id: UUID!

  """Description of the option."""
  description: String!

  """Indicates whether this option is the correct"""
  isCorrect: Boolean!

  """Unique identifier for the reward Item Id."""
  rewardItemId: UUID

  """Number of users who selected this option."""
  voteCount: NonNegativeInt!

  """Reward amount for the prediction option ."""
  rewardItemAmount: NonNegativeInt

  """List of all earned rewards"""
  earnableRewards: [LiveLikeReward!]

  """List of fields in this object that support translation"""
  translatableFields: [String!]
}

input LiveLikeTextPredictionOptionLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """Description of the option"""
  description: NonEmptyString!
}

type LiveLikeTextPredictionVote implements LiveLikeWidgetInteractionBase {
  """Unique ID of the text prediction vote"""
  id: UUID!

  """ID of the profile associated with the text prediction vote"""
  profileId: UUID!

  """ID of the widget associated with the text prediction vote"""
  widgetId: UUID!

  """Kind of the widget Interaction"""
  widgetKind: LiveLikeWidgetInteractionEnum!

  """Text prediction widget associated with the text prediction vote"""
  widget: LiveLikeTextPrediction!

  """Timestamp when the widget was created."""
  createdAt: String!

  """Vote option associated with the text prediction vote"""
  optionId: UUID!

  """Claim token for the text prediction Vote"""
  claimToken: JWT!

  """List of rewards granted for this answer."""
  rewards: [LiveLikeReward!]

  """Leaderboard rewards associated with the text prediction vote"""
  leaderboardRewards: [LiveLikeLeaderboardReward!]
}

input LiveLikeTextPredictionVoteCreateInput {
  widgetId: UUID!
  optionId: UUID!
}

input LiveLikeTextPredictionVoteUpdateInput {
  id: UUID!
  widgetId: UUID!
  optionId: UUID!
}

"""Represents an text quiz widget."""
type LiveLikeTextQuiz implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the text quiz."""
  id: UUID!

  """Client identifier associated with this quiz."""
  clientId: NonEmptyString!

  """Program identifier associated with this quiz."""
  programId: UUID!

  """The question for the quiz to be made"""
  question: NonEmptyString!

  """List of choices available for this quiz."""
  choices: [LiveLikeTextQuizChoice!]!

  """Optional custom metadata for the widget."""
  customData: String

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Total number of unique users who interacted with the widget."""
  uniqueImpressionCount: NonNegativeInt

  """List of sponsor IDs associated with this Text Quiz."""
  sponsorIds: [UUID!]

  """Contains count-based metrics such as interactions."""
  reportCount: LiveLikeWidgetReportCount

  """Additional widget attributes in key-value format."""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """Information about the user that created the widget."""
  createdBy: LiveLikeWidgetCreator!

  """The ISO8601 DateTime when the widget stops accepting interactions."""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds."""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive."""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling."""
  publishDelay: Duration!

  """Program-scheduled datetime when the quiz is expected to appear."""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created."""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget."""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published."""
  publishedAt: DateTimeISO
}

type LiveLikeTextQuizAnswer implements LiveLikeWidgetInteractionBase {
  """Unique identifier of the text quiz answer."""
  id: UUID!

  """ID of the profile who submitted the answer."""
  profileId: UUID!

  """ID of the widget this answer belongs to."""
  widgetId: UUID!

  """Type of widget interaction."""
  widgetKind: LiveLikeWidgetInteractionEnum!

  """The text quiz widget associated with this answer."""
  widget: LiveLikeTextQuiz!

  """Timestamp when the answer was created."""
  createdAt: String!

  """List of rewards granted for this answer."""
  rewards: [LiveLikeReward!]

  """List of leaderboard rewards associated with this answer."""
  leaderboardRewards: [LiveLikeLeaderboardReward!]

  """Identifier of the choice selected by the user."""
  choiceId: UUID!
}

input LiveLikeTextQuizAnswerCreateInput {
  """ID of the widget instance for which the answer is submitted."""
  widgetId: UUID!

  """ID of the choice selected by the user."""
  choiceId: UUID!
}

input LiveLikeTextQuizAnswerUpdateInput {
  """ID of the text quiz answer to update."""
  id: UUID!

  """ID of the widget instance for which the answer is submitted."""
  widgetId: UUID!

  """ID of the choice selected by the user."""
  choiceId: UUID!
}

""" Represents a choice in a text quiz. Includes correctness, user response count, and localization metadata.
"""
type LiveLikeTextQuizChoice implements LiveLikeNode {
  """Unique identifier for the choice."""
  id: UUID!

  """Description of the choice."""
  description: String!

  """Indicates whether this choice is the correct answer"""
  isCorrect: Boolean!

  """Number of users who selected this choice."""
  answerCount: NonNegativeInt!

  """List of fields in this object that support translation"""
  translatableFields: [String!]
}

input LiveLikeTextQuizChoiceLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """Description of the choice"""
  description: NonEmptyString!
}

"""Represents a choice option for a text quiz."""
input LiveLikeTextQuizCreateChoiceInput {
  """Description of the choice."""
  description: NonEmptyString!

  """Indicates whether this choice is the correct answer."""
  isCorrect: Boolean!

  """TextQuiz choice localized data"""
  localizedData: [LiveLikeTextQuizChoiceLocalizedInput!]
}

input LiveLikeTextQuizCreateInput {
  """ID of the program to create the prediction for"""
  programId: UUID!

  """A free-form field used for custom behaviors"""
  customData: NonEmptyString

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!

  """List of choices for this prediction, min 2 and max 4"""
  choices: [LiveLikeTextQuizCreateChoiceInput!]!

  """A iso8601 duration hint for when a Widget should be timed out"""
  timeout: Duration

  """The ISO8601 DateTime that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this Text Quiz. Note that only valid sponsor_ids will be linked to a Text Quiz.
  """
  sponsorIds: [UUID!]

  """TextQuiz localized data"""
  localizedData: [LiveLikeTextQuizLocalizedInput!]
}

input LiveLikeTextQuizLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47â (RFC 5646â) standard.
  """
  language: Locale!

  """The prompt or question for the prediction to be made"""
  question: NonEmptyString!
}

type LiveLikeTokenGate {
  contractAddress: NonEmptyString!
  networkType: LiveLikeTokenGateNetworkTypeEnum!
  tokenType: LiveLikeTokenGateTokenTypeEnum!
  attributes: [LiveLikeTokenGateAttribute!]
}

type LiveLikeTokenGateAttribute {
  trainType: NonEmptyString!
  value: NonEmptyString!
}

input LiveLikeTokenGateAttributesInput {
  trainType: NonEmptyString!
  value: NonEmptyString!
}

input LiveLikeTokenGateInput {
  contractAddress: NonEmptyString!
  networkType: LiveLikeTokenGateNetworkTypeEnum!
  tokenType: LiveLikeTokenGateTokenTypeEnum!
  attributes: [LiveLikeTokenGateAttributesInput!]
}

enum LiveLikeTokenGateNetworkTypeEnum {
  ETHEREUM
  POLYGON
  CHILIZ
  HEDERA
}

enum LiveLikeTokenGateTokenTypeEnum {
  FUNGIBLE
  NON_FUNGIBLE
}

input LiveLikeUnlinkRewardTableWithProgramInput {
  programId: UUID!
  rewardTableId: UUID!
}

type LiveLikeUserBadge implements LiveLikeNode {
  id: UUID!
  badgeId: UUID!
  awardedAt: DateTimeISO!
  profile: LiveLikeProfile!
  badge: LiveLikeBadge!
}

type LiveLikeUserBadgeCollection {
  edges: [LiveLikeUserBadgeEdge!]
  page: LiveLikePage!
}

type LiveLikeUserBadgeEdge {
  node: LiveLikeUserBadge!
  cursor: String
}

type LiveLikeUserQuest implements LiveLikeNode {
  id: UUID!
  profileId: UUID!
  questId: UUID!
  status: LiveLikeUserQuestStatusEnum!
  quest: LiveLikeQuest!
  userQuestTasks: [LiveLikeUserQuestTask!]
  rewardsStatus: LiveLikeUserQuestRewardStatus!
  timerExpired: Boolean
  activeUntil: DateTimeISO
  completedAt: NonEmptyString
  createdAt: NonEmptyString!
  rewardsClaimedAt: NonEmptyString
}

type LiveLikeUserQuestCollection implements LiveLikeConnection {
  edges: [LiveLikeUserQuestEdge!]
  page: LiveLikePage!
}

type LiveLikeUserQuestEdge implements LiveLikeEdge {
  node: LiveLikeUserQuest!
  cursor: String
}

input LiveLikeUserQuestInput {
  profileId: UUID!
  questId: UUID!
}

type LiveLikeUserQuestReward implements LiveLikeNode {
  id: UUID!
  userQuestId: UUID!
  questReward: LiveLikeQuestReward!
  rewardStatus: LiveLikeUserQuestRewardStatus!
}

type LiveLikeUserQuestRewardsConnection implements LiveLikeConnection {
  edges: [LiveLikeUserQuestRewardsEdge]
  page: LiveLikePage!
}

type LiveLikeUserQuestRewardsEdge implements LiveLikeEdge {
  node: LiveLikeUserQuestReward!
  cursor: String
}

input LiveLikeUserQuestRewardsInput {
  userQuestId: UUID!
  rewardStatus: LiveLikeUserQuestRewardStatus
}

enum LiveLikeUserQuestRewardStatus {
  CLAIMED
  UNCLAIMED
}

input LiveLikeUserQuestsInput {
  clientId: NonEmptyString
  questId: UUID
  status: LiveLikeUserQuestStatusEnum
  rewardsStatus: LiveLikeUserQuestRewardStatus
}

input LiveLikeUserQuestsTaskProgressInput {
  userQuestTaskId: UUID!
  customIncrement: NonNegativeInt
  customProgress: NonNegativeInt
}

enum LiveLikeUserQuestStatusEnum {
  INCOMPLETE
  CANCELLED
  COMPLETED
}

type LiveLikeUserQuestTask implements LiveLikeNode {
  id: UUID!
  userQuestId: UUID!
  questTask: LiveLikeQuestTask!
  status: LiveLikeUserQuestTaskStatusEnum!
  progress: NonNegativeInt
  completedAt: DateTimeISO
  createdAt: NonEmptyString!
}

type LiveLikeUserQuestTaskProgress {
  userQuestTaskId: UUID!
  id: UUID!
  customIncrement: NonNegativeInt
  customProgress: NonNegativeInt
  userQuest: LiveLikeUserQuest!
}

enum LiveLikeUserQuestTaskStatusEnum {
  INCOMPLETE
  COMPLETED
}

type LiveLikeUserReaction implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  targetId: NonEmptyString!
  reactionId: UUID!
  reactionSpaceId: UUID!
  customData: NonEmptyString
  reactedById: UUID!
  createdAt: NonEmptyString!
}

type LiveLikeUserReactionCollection implements LiveLikeConnection {
  edges: [LiveLikeUserReactionEdge!]
  page: LiveLikePage!
}

type LiveLikeUserReactionCountCollection {
  edges: [LiveLikeUserReactionCountEdge!]
  page: LiveLikePage!
}

type LiveLikeUserReactionCountEdge {
  node: LiveLikeReactions!
  cursor: String
}

input LiveLikeUserReactionCountsGetInput {
  page: PositiveInt
  reactionSpaceId: UUID!
  targetId: [NonEmptyString!]
}

input LiveLikeUserReactionCreateInput {
  targetId: NonEmptyString!
  reactionId: UUID!
  reactionSpaceId: UUID!
  customData: NonEmptyString
}

type LiveLikeUserReactionEdge implements LiveLikeEdge {
  node: LiveLikeUserReaction!
  cursor: String
}

input LiveLikeUserReactionsGetInput {
  clientId: NonEmptyString!
  targetId: [NonEmptyString!]
  targetGroupId: NonEmptyString
  reactionId: UUID
  reactionSpaceIds: [UUID!]
  reactedById: UUID
  page: PositiveInt
  pageSize: PositiveInt
}

type LiveLikeVideoAlert implements LiveLikeWidgetBase & LiveLikeNode {
  """Unique identifier of the video alert"""
  id: UUID!

  """Client identifier associated with this video alert"""
  clientId: NonEmptyString!

  """Program identifier associated with this video alert"""
  programId: UUID!

  """Information about the user that created the widget"""
  createdBy: LiveLikeWidgetCreator!

  """Kind of widget"""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g.,  PENDING, SCHEDULED, PUBLISHED, INFLIGHT etc).
  """
  status: LiveLikeWidgetStatusEnum!

  """Whether pubnub is enabled."""
  pubnubEnabled: Boolean!

  """Optional custom metadata for the widget"""
  customData: String

  """Additional widget attributes in key-value format"""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """List of sponsor IDs associated with this video alert"""
  sponsorIds: [UUID!]

  """Total number of unique users who interacted with the widget"""
  uniqueImpressionCount: NonNegativeInt

  """Contains count-based metrics such as interactions"""
  reportCount: LiveLikeWidgetReportCount

  """ISO8601 DateTime when the widget stops accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """Duration (ISO8601) for which the widget remains interactive"""
  timeout: Duration!

  """Delay (ISO8601) before the widget is published after scheduling"""
  publishDelay: Duration!

  """Program-scheduled datetime when the video alert is expected to appear"""
  programDateTime: DateTimeISO

  """Timestamp when the widget was created"""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget"""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published"""
  publishedAt: DateTimeISO

  """title of the video alert"""
  title: NonEmptyString

  """text of the video alert"""
  text: NonEmptyString

  """url of the video file """
  videoUrl: URL!

  """url of the link"""
  linkUrl: URL

  """label describing the link"""
  linkLabel: NonEmptyString
}

input LiveLikeVideoAlertCreateInput {
  """ ID of the program to create the video alert"""
  programId: UUID!

  """free-form field used for custom behaviors"""
  customData: String

  """An array of key value pairs used for custom behaviors"""
  widgetAttributes: [LiveLikeKeyValuePairInput!]

  """
  Links the sponsors with this Alert. 
  Note only valid sponsor ids will be linked to video alert.
  """
  sponsorIds: [UUID!]

  """ISO8601 duration hint for when a Widget should be timed out"""
  timeout: Duration

  """ISO8601 DateTime that the widget will stop accepting interactions"""
  interactiveUntil: DateTimeISO

  """Video playback time in milliseconds"""
  playbackTimeMs: NonNegativeInt

  """title of the video alert"""
  title: NonEmptyString

  """text of the video alert"""
  text: NonEmptyString

  """url of the video file """
  videoUrl: URL!

  """url of the link"""
  linkUrl: URL

  """label describing the link"""
  linkLabel: NonEmptyString

  """Video Alert localized data"""
  localizedData: [LiveLikeVideoAlertLocalizedInput!]
}

input LiveLikeVideoAlertLocalizedInput {
  """
  Localized language a string that conforms to the BCP-47 (RFC 5646) standard 
  """
  language: Locale!

  """title of the video alert"""
  title: NonEmptyString

  """text of the video alert"""
  text: NonEmptyString

  """label describing the link"""
  linkLabel: NonEmptyString
}

union LiveLikeWidget = LiveLikeTextPoll | LiveLikeImagePoll | LiveLikeRichPost | LiveLikeTextQuiz | LiveLikeImageQuiz | LiveLikeTextPrediction | LiveLikeImagePrediction | LiveLikeTextPredictionFollowUp | LiveLikeImagePredictionFollowUp | LiveLikeAlert | LiveLikeVideoAlert | LiveLikeSocialEmbed

"""Base widget type containing common fields shared across"""
interface LiveLikeWidgetBase implements LiveLikeNode {
  """Unique identifier of the widget."""
  id: UUID!

  """Client identifier associated with this widget."""
  clientId: NonEmptyString!

  """Program identifier associated with this widget."""
  programId: UUID!

  """Kind of widget (e.g., POST, POLL, PREDICTION, ALERT)."""
  kind: LiveLikeWidgetKindEnum!

  """
  Current status of the widget (e.g., PENDING, SCHEDULED, PUBLISHED, INFLIGHT).
  """
  status: LiveLikeWidgetStatusEnum!

  """Optional custom metadata for the widget."""
  customData: String

  """Information about the user that created the widget."""
  createdBy: LiveLikeWidgetCreator!

  """Total number of unique users who interacted with the widget."""
  uniqueImpressionCount: NonNegativeInt

  """The ISO8601 DateTime when the widget stops accepting interactions."""
  interactiveUntil: DateTimeISO

  """Video playback time at which the widget appears, in milliseconds."""
  playbackTimeMs: NonNegativeInt

  """Additional widget attributes in key-value format."""
  widgetAttributes: [LiveLikeKeyValuePair!]

  """List of sponsor IDs associated with this widget."""
  sponsorIds: [UUID!]

  """Contains count-based metrics such as interactions and reports."""
  reportCount: LiveLikeWidgetReportCount

  """Timestamp when the widget was created."""
  createdAt: DateTimeISO!

  """Scheduled datetime for the widget."""
  scheduledAt: DateTimeISO

  """Datetime when the widget was actually published."""
  publishedAt: DateTimeISO

  """Duration (ISO8601) for which the widget remains interactive."""
  timeout: Duration!

  """Whether pubnub is enabled (if applicable)."""
  pubnubEnabled: Boolean!

  """
  Delay (ISO8601) before the widget is published after scheduling (if applicable).
  """
  publishDelay: Duration!

  """
  Program-scheduled datetime when the widget is expected to appear (if applicable).
  """
  programDateTime: DateTimeISO
}

type LiveLikeWidgetCollection {
  edges: [LiveLikeWidgetEdge]
  page: LiveLikePage!
  order: LiveLikeWidgetOrder
}

type LiveLikeWidgetCreator {
  id: UUID!
  name: NonEmptyString!
  customId: NonEmptyString
  avatar: Avatar
}

input LiveLikeWidgetDeleteInput {
  id: UUID!
  kind: LiveLikeWidgetKindEnum!
}

type LiveLikeWidgetEdge {
  node: LiveLikeWidget!
  cursor: String
}

input LiveLikeWidgetGetInput {
  page: PositiveInt
  status: LiveLikeWidgetStatusEnum
  kinds: [LiveLikeWidgetKindEnum!]
  since: NonEmptyString
  until: NonEmptyString
}

"""
DEPRECATED: Use widget specific one 
(TextPollVote, ImagePollVote)
"""
type LiveLikeWidgetInteraction {
  id: UUID!
  widgetId: UUID!
  optionId: UUID!
  profileId: UUID!
  createdAt: String!
  widgetKind: LiveLikeWidgetInteractionEnum!
  widget: LiveLikeWidget
  rewards: [LiveLikeReward!]
  leaderboardRewards: [LiveLikeLeaderboardReward!]
}

interface LiveLikeWidgetInteractionBase {
  id: UUID!
  profileId: UUID!
  widgetId: UUID!
  widgetKind: LiveLikeWidgetInteractionEnum!
  createdAt: String!
  rewards: [LiveLikeReward!]
  leaderboardRewards: [LiveLikeLeaderboardReward!]
}

interface LiveLikeWidgetInteractionBaseCreateInput {
  widgetId: UUID!
}

"""Remove not used in scehma used in resolver"""
input LiveLikeWidgetInteractionCreateInput {
  kind: LiveLikeWidgetInteractionEnum!
  widgetId: UUID!
  optionId: UUID!
}

enum LiveLikeWidgetInteractionEnum {
  TEXT_PREDICTION
  IMAGE_PREDICTION
  TEXT_QUIZ
  IMAGE_QUIZ
  TEXT_POLL
  IMAGE_POLL
}

type LiveLikeWidgetInteractions {
  kind: LiveLikeWidgetInteractionEnum!
  interactions: [LiveLikeWidgetInteractionUnion!]
}

input LiveLikeWidgetInteractionsInput {
  kind: LiveLikeWidgetInteractionEnum!
  ids: [UUID!]!
}

union LiveLikeWidgetInteractionUnion = LiveLikeTextPollVote | LiveLikeImagePollVote | LiveLikeTextQuizAnswer | LiveLikeImageQuizAnswer | LiveLikeTextPredictionVote | LiveLikeImagePredictionVote

"""Remove not used in scehma used in resolver"""
input LiveLikeWidgetInteractionUpdateInput {
  id: UUID!
  kind: LiveLikeWidgetInteractionEnum!
  widgetId: UUID!
  optionId: UUID!
}

enum LiveLikeWidgetKindEnum {
  SOCIAL_EMBED
  ALERT
  VIDEO_ALERT
  TEXT_PREDICTION
  IMAGE_PREDICTION
  TEXT_PREDICTION_FOLLOW_UP
  IMAGE_PREDICTION_FOLLOW_UP
  TEXT_QUIZ
  IMAGE_QUIZ
  TEXT_POLL
  IMAGE_POLL
  RICH_POST
}

type LiveLikeWidgetOrder {
  field: LiveLikeWidgetOrderField
  order: LiveLikeOrderEnum
}

enum LiveLikeWidgetOrderField {
  RECENT
  CREATED_AT
  SCHEDULED_AT
  PUBLISHED_AT
}

input LiveLikeWidgetOrderInput {
  field: LiveLikeWidgetOrderField!
  order: LiveLikeOrderEnum
}

type LiveLikeWidgetPublish {
  status: LiveLikeWidgetStatusEnum!
  scheduledAt: DateTimeISO
  publishedAt: DateTimeISO

  """An ISO8601 duration to delay publishing"""
  publishDelay: String

  """An ISO8601 date hint to sync widget to video"""
  programDateTime: DateTimeISO
}

input LiveLikeWidgetPublishInput {
  """ Widget unique ID """
  widgetId: UUID!

  """ An ISO8601 duration to delay publishing """
  publishDelay: String

  """ An ISO8601 date hint to sync widget to video """
  programDateTime: DateTimeISO
}

type LiveLikeWidgetReport implements LiveLikeNode {
  id: UUID!
  clientId: NonEmptyString!
  programId: UUID!
  widgetKind: LiveLikeWidgetKindEnum!
  widgetId: UUID!
  createdAt: DateTimeISO!
  comment: String
  moderatedAt: DateTimeISO
  moderatedBy: UUID
  moderatorComment: String
  status: LiveLikeWidgetReportStatusEnum!
}

type LiveLikeWidgetReportCollection implements LiveLikeConnection {
  edges: [LiveLikeWidgetReportEdge]
  page: LiveLikePage!
}

type LiveLikeWidgetReportCount {
  total: NonNegativeInt!
  pending: NonNegativeInt!
  accepted: NonNegativeInt!
  dismissed: NonNegativeInt!
}

type LiveLikeWidgetReportEdge implements LiveLikeEdge {
  node: LiveLikeWidgetReport!
  cursor: String
}

input LiveLikeWidgetReportInput {
  widgetKind: LiveLikeWidgetKindEnum!
  widgetId: UUID!
  comment: NonEmptyString
}

input LiveLikeWidgetReportsInput {
  clientId: NonEmptyString
  programId: UUID
  widgetKind: LiveLikeWidgetKindEnum
  widgetId: UUID
  createdById: UUID
  createdSince: DateTimeISO
  createdUntil: DateTimeISO
  moderatedById: UUID
  moderatedSince: DateTimeISO
  moderatedUntil: DateTimeISO
  status: LiveLikeWidgetReportStatusEnum
  page: PositiveInt
}

enum LiveLikeWidgetReportStatusEnum {
  PENDING
  ACCEPTED
  DISMISSED
}

enum LiveLikeWidgetStatusEnum {
  PENDING
  SCHEDULED
  PUBLISHED
  INFLIGHT
}

"""The locale in the format of a BCP 47 (RFC 5646) standard string"""
scalar Locale

type Localization {
  value: String
  language: String
}

type Media {
  image: Image
  clip: String
  _id: MongoID
}

type Menu {
  schemaVersion: String!
  tenant: String!
  uuid: String
  cmsId: String
  isPublished: Boolean
  language: String!
  id: String!
  title: String!
  links: [MenuLinks]
  _id: MongoID!
}

type MenuLinks {
  text: String!
  url: String
  weight: String!
  tagGroups: [TagGroup]
  tags: [TagV2]
  options: MenuOptions
  _id: MongoID
  children: [MenuLinks]
}

type MenuOptions {
  target: String
  expanded: Boolean
  images: [ImageWithStyle]
  routes: [MenuRoutes]
  attributes: MenuOptionsAttributes
  _id: MongoID
}

type MenuOptionsAttributes {
  title: String
  class: [String]
}

type MenuRoutes {
  id: String
  path: String
  title: String
  _id: MongoID
}

type Metadata {
  cdn: String
}

type ModuleMetaData {
  hash: String!
  brand: ContentBrand

  """
  Represents the community this content module belongs to (ex. NFL, NBA, BR).
  In other words, the chosen Tag/Channel we want to display, and often but
  not always the destination the user would tap through to.
  """
  communityTag: TagV2

  """Represents the contentId for video."""
  videoContentId: String

  """Represents the tenant."""
  tenant: Tenant

  """
  Represents author of the content within a Content Module. In most cases this would be Creators (creator tags).
  """
  author: TagV2
}

enum ModuleOrientation {
  Landscape
  Portrait
}

enum ModuleState {
  SCHEDULED
  UNPROGRAMMED
  PROGRAMMED
}

"""
The `ID` scalar type represents a unique MongoDB identifier in collection. MongoDB by default use 12-byte ObjectId value (https://docs.mongodb.com/manual/reference/bson-types/#objectid). But MongoDB also may accepts string or integer as correct values for _id field.
"""
scalar MongoID

"""TEST Mutate the Hydration Station Social Entities"""
type Mutation {
  """
  flushAdRegistryCache | Ads API
  ----------------------------------------------
  Flushes the cache for ads registries and metadata based on the operationName
  Returns the number of entries deleted
  """
  flushAdRegistryCache(operationName: String!): Int

  """
  flushAdSiteCache | Ads API
  ----------------------------------------------
  Flushes the cache for ads site configurations
  Returns the number of entries deleted
  """
  flushAdSiteCache(siteCache: String): Boolean
  createStandaloneContentModule(contentId: ID!, lastModifiedBy: String!, channels: [TagComponent!]!, title: String!, description: String!, thumbnail: String!, contentType: ContentModuleType!, orientation: ModuleOrientation, expiresAt: Date, scheduledDate: Date, allowedCountries: [String], commentsEnabled: Boolean, thumbnailAccreditation: String, thumbnailCopyright: String, hidden: Boolean, hiddenExpiresAt: Date): StandaloneContentModule!
  updateStandaloneContentModule(contentId: ID, lastModifiedBy: String, channels: [TagComponent], title: String, description: String, thumbnail: String, contentType: ContentModuleType, expiresAt: Date, scheduledDate: Date, id: ID!, isAlerted: Boolean, allowedCountries: [String], commentsEnabled: Boolean, thumbnailAccreditation: String, thumbnailCopyright: String, updateProgrammingTimestamp: Boolean, hidden: Boolean, hiddenExpiresAt: Date): ContentModule!
  createPackageContentModule(contentId: ID @deprecated(reason: "Not used field"), lastModifiedBy: String!, channels: [TagComponent!]!, packageType: PackageType, orientation: ModuleOrientation, title: String!, description: String, contentType: ContentModuleType!, expiresAt: Date, scheduledDate: Date, allowedCountries: [String], commentsEnabled: Boolean, packageTag: String, hidden: Boolean, hiddenExpiresAt: Date): ContentModule!
  updatePackageContentModule(lastModifiedBy: String, channels: [TagComponent], title: String, description: String, expiresAt: Date, scheduledDate: Date, contentModuleId: ID!, isAlerted: Boolean, allowedCountries: [String], commentsEnabled: Boolean, packageTag: String, hidden: Boolean, hiddenExpiresAt: Date): ContentModule!
  addContentToPackage(packageModuleId: String!, contentId: ID, contentType: ContentModuleType, position: Int!, title: String!, description: String!, thumbnail: String!, allowedCountries: [String], lastModifiedBy: String!, commentsEnabled: Boolean, contentModuleId: ID, thumbnailAccreditation: String, thumbnailCopyright: String, scheduledDate: Date, hidden: Boolean, hiddenExpiresAt: Date): ContentModule!
  deleteContentModule(id: ID!): String!
  expireContentModules: [Int!]! @deprecated(reason: "use deleteContentModule instead")
  upsertStandaloneContentModules(data: [ContentModuleInput!]!, delete: [ID!]): [ContentModule!]!
  createExternalArticle(url: String!, source: String!, providerName: String!, created: Date): ExternalArticle!
  createStaticPackages(packageTypes: [PackageType!]!, channels: [TagComponent!], lastModifiedBy: String!, contentType: ContentModuleType!, allowedCountries: [String], commentsEnabled: Boolean): [ContentModule]!
  deleteContentFromPackage(packageContentModuleId: String!, contentModuleId: String!): Boolean
  upsertPackageContentModules(contents: [PackageContent], packages: [PackageInput], delete: [ID!]): [PackageContentModule]
  upsertVideoState(data: VideoMetadataInput!): VideoV2Metadata
  deleteDuplicateScheduledHighlightsPackages: String
  deleteContentModuleByContentId(contentId: String!, contentType: ContentModuleType): DeleteVideoContentModulesResult!
  login(email: String!, password: String!): String

  """
  TEST Mutation for Tweets from Hydration Station no used in Production Clients ONLY DEV
  """
  createTweetById(id: ID!): Tweet!
  createLiveLikeProfile(input: LiveLikeProfileCreateInput!): LiveLikeProfileAuth
  createLiveLikeProfileByCustomId(input: LiveLikeProfileByCustomIdCreateInput!): LiveLikeProfileAuth
  updateLiveLikeProfile(input: LiveLikeProfileUpdateInput!): LiveLikeProfile
  deleteLiveLikeProfile(id: UUID!): Boolean
  blockLiveLikeProfile(profileId: UUID!): LiveLikeBlockProfile
  deleteLiveLikeProfileBlock(id: UUID!): Boolean
  createLiveLikeProfileRelationshipType(input: LiveLikeProfileRelationshipTypeCreateInput!): LiveLikeProfileRelationshipType
  createLiveLikeProfileRelationship(input: LiveLikeProfileRelationshipCreateInput!): LiveLikeProfileRelationship
  deleteLiveLikeProfileRelationshipType(id: UUID!): Boolean
  deleteLiveLikeProfileRelationship(id: UUID!): Boolean
  createLiveLikeRole(input: LiveLikeRoleCreateInput!): LiveLikeRole
  createLiveLikeRoleAssignment(input: LiveLikeRoleAssignmentCreateInput!): LiveLikeRoleAssignment
  createLiveLikeProgram(input: LiveLikeProgramCreateInput!): LiveLikeProgram
  updateLiveLikeProgram(input: LiveLikeProgramUpdateInput!): LiveLikeProgram
  startLiveLikeProgram(id: UUID!): LiveLikeProgramSchedule
  stopLiveLikeProgram(id: UUID!): LiveLikeProgramSchedule
  updateLiveLikeProgramByCustomId(input: LiveLikeProgramUpdateByCustomIdInput!): LiveLikeProgram
  deleteLiveLikeProgram(id: UUID!): Boolean
  deleteLiveLikeProgramByCustomId(input: LiveLikeProgramDeleteByCustomIdInput!): Boolean
  publishLiveLikeWidget(kind: LiveLikeWidgetKindEnum!, input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish
  reportLiveLikeWidget(input: LiveLikeWidgetReportInput!): LiveLikeWidgetReport
  deleteLiveLikeWidget(input: LiveLikeWidgetDeleteInput!): Boolean
  createLiveLikeTextPoll(input: LiveLikeTextPollCreateInput!): LiveLikeTextPoll
  createLiveLikeImagePoll(input: LiveLikeImagePollCreateInput!): LiveLikeImagePoll
  createLiveLikePollVote(input: LiveLikePollVoteCreateInput!): LiveLikeWidgetInteraction @deprecated(reason: "Use widget specific one (createTextPollVote, createImagePollVote)")
  updateLiveLikePollVote(input: LiveLikePollVoteUpdateInput!): LiveLikeWidgetInteraction @deprecated(reason: "Use widget specific one (updateTextPollVote, updateImagePollVote)")

  """ Vote on a text poll """
  createLiveLikeTextPollVote(input: LiveLikeTextPollVoteCreateInput!): LiveLikeTextPollVote

  """ Update Vote on a voted text poll """
  updateLiveLikeTextPollVote(input: LiveLikeTextPollVoteUpdateInput!): LiveLikeTextPollVote

  """ Vote on a image poll """
  createLiveLikeImagePollVote(input: LiveLikeImagePollVoteCreateInput!): LiveLikeImagePollVote

  """ Update Vote on a voted image poll """
  updateLiveLikeImagePollVote(input: LiveLikeImagePollVoteUpdateInput!): LiveLikeImagePollVote

  """Publish a Text Poll widget"""
  publishLiveLikeTextPoll(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Publish a Image Poll widget"""
  publishLiveLikeImagePoll(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Delete a Text Poll widget"""
  deleteLiveLikeTextPoll(id: UUID!): Boolean

  """Delete a Image Poll widget"""
  deleteLiveLikeImagePoll(id: UUID!): Boolean

  """Create a Rich Post widget"""
  createLiveLikeRichPost(input: LiveLikeRichPostCreateInput!): LiveLikeRichPost

  """Publish a Rich Post widget"""
  publishLiveLikeRichPost(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Delete a Rich Post widget"""
  deleteLiveLikeRichPost(id: UUID!): Boolean

  """
  Creates a new text quiz widget with the provided input.
  Returns the created TextQuiz object.
  """
  createLiveLikeTextQuiz(input: LiveLikeTextQuizCreateInput!): LiveLikeTextQuiz

  """
  Creates a new image quiz widget with the provided input.
  Returns the created ImageQuiz object.
  """
  createLiveLikeImageQuiz(input: LiveLikeImageQuizCreateInput!): LiveLikeImageQuiz

  """ Answer on a text quiz """
  createLiveLikeTextQuizAnswer(input: LiveLikeTextQuizAnswerCreateInput!): LiveLikeTextQuizAnswer

  """ Update answer on a answered text quiz """
  updateLiveLikeTextQuizAnswer(input: LiveLikeTextQuizAnswerUpdateInput!): LiveLikeTextQuizAnswer

  """ Answer on a image quiz """
  createLiveLikeImageQuizAnswer(input: LiveLikeImageQuizAnswerCreateInput!): LiveLikeImageQuizAnswer

  """ Update answer on a answered image quiz """
  updateLiveLikeImageQuizAnswer(input: LiveLikeImageQuizAnswerUpdateInput!): LiveLikeImageQuizAnswer

  """Publish a Text Quiz widget"""
  publishLiveLikeTextQuiz(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Publish a Image Quiz widget"""
  publishLiveLikeImageQuiz(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Delete a Text Quiz widget"""
  deleteLiveLikeTextQuiz(id: UUID!): Boolean

  """Delete a Image Quiz widget"""
  deleteLiveLikeImageQuiz(id: UUID!): Boolean

  """
  Creates a new text prediction widget with the provided input.
  Returns the created TextPrediction object.
  """
  createLiveLikeTextPrediction(input: LiveLikeTextPredictionCreateInput!): LiveLikeTextPrediction

  """
  Creates a new text prediction follow up widget with the provided input.
  Returns the created TextPredictionFollowUp object.
  """
  createLiveLikeTextPredictionFollowUp(input: LiveLikeTextPredictionFollowUpCreateInput!): LiveLikeTextPredictionFollowUp

  """
  Creates a new image prediction widget with the provided input.
  Returns the created ImagePrediction object.
  """
  createLiveLikeImagePrediction(input: LiveLikeImagePredictionCreateInput!): LiveLikeImagePrediction

  """
  Creates a new image prediction follow up widget with the provided input.
  Returns the created ImagePredictionFollowUp object.
  """
  createLiveLikeImagePredictionFollowUp(input: LiveLikeImagePredictionFollowUpCreateInput!): LiveLikeImagePredictionFollowUp

  """ Vote on a text prediction """
  createLiveLikeTextPredictionVote(input: LiveLikeTextPredictionVoteCreateInput!): LiveLikeTextPredictionVote

  """ Update Vote on a voted text prediction """
  updateLiveLikeTextPredictionVote(input: LiveLikeTextPredictionVoteUpdateInput!): LiveLikeTextPredictionVote

  """ Vote on a image prediction """
  createLiveLikeImagePredictionVote(input: LiveLikeImagePredictionVoteCreateInput!): LiveLikeImagePredictionVote

  """ Update Vote on a voted image prediction """
  updateLiveLikeImagePredictionVote(input: LiveLikeImagePredictionVoteUpdateInput!): LiveLikeImagePredictionVote

  """Publish a Text Prediction widget"""
  publishLiveLikeTextPrediction(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Publish a Text Prediction Follow Up widget"""
  publishLiveLikeTextPredictionFollowUp(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Publish a Image Prediction widget"""
  publishLiveLikeImagePrediction(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Publish a Image Prediction Follow Up widget"""
  publishLiveLikeImagePredictionFollowUp(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Delete a Text Prediction widget"""
  deleteLiveLikeTextPrediction(id: UUID!): Boolean

  """Delete a Text Prediction Follow up widget"""
  deleteLiveLikeTextPredictionFollowUp(id: UUID!): Boolean

  """Delete a Image Prediction widget"""
  deleteLiveLikeImagePrediction(id: UUID!): Boolean

  """Delete a Image Prediction Follow up widget"""
  deleteLiveLikeImagePredictionFollowUp(id: UUID!): Boolean

  """Create a Alert widget"""
  createLiveLikeAlert(input: LiveLikeAlertCreateInput!): LiveLikeAlert

  """Create a Video Alert widget"""
  createLiveLikeVideoAlert(input: LiveLikeVideoAlertCreateInput!): LiveLikeVideoAlert

  """Publish a Alert widget"""
  publishLiveLikeAlert(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Publish a Video Alert widget"""
  publishLiveLikeVideoAlert(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Delete a Alert widget"""
  deleteLiveLikeAlert(id: UUID!): Boolean

  """Delete a Video Alert widget"""
  deleteLiveLikeVideoAlert(id: UUID!): Boolean

  """Create a SocialEmbed widget"""
  createLiveLikeSocialEmbed(input: LiveLikeSocialEmbedCreateInput!): LiveLikeSocialEmbed

  """Publish a SocialEmbed widget"""
  publishLiveLikeSocialEmbed(input: LiveLikeWidgetPublishInput!): LiveLikeWidgetPublish

  """Delete a SocialEmbed widget"""
  deleteLiveLikeSocialEmbed(id: UUID!): Boolean
  createLiveLikeReactionSpace(input: LiveLikeReactionSpaceCreateInput!): LiveLikeReactionSpace
  updateLiveLikeReactionSpace(input: LiveLikeReactionSpaceUpdateInput!): LiveLikeReactionSpacePatch
  deleteLiveLikeReactionSpace(input: LiveLikeReactionSpaceDeleteInput!): Boolean
  createLiveLikeUserReaction(input: LiveLikeUserReactionCreateInput!): LiveLikeUserReaction
  deleteLiveLikeUserReaction(id: UUID!): Boolean
  createLiveLikeCommentBoard(input: LiveLikeCommentBoardCreateInput!): LiveLikeCommentBoard
  updateLiveLikeCommentBoard(input: LiveLikeCommentBoardUpdateInput!): LiveLikeCommentBoard
  deleteLiveLikeCommentBoard(id: UUID!): Boolean
  createLiveLikeComment(input: LiveLikeCommentCreateInput!): LiveLikeComment
  createLiveLikeCommentReply(input: LiveLikeCommentReplyCreateInput!): LiveLikeComment
  deleteLiveLikeComment(id: UUID!): Boolean
  createLiveLikeCommentReport(input: LiveLikeCommentReportCreateInput!): LiveLikeCommentReport
  dismissLiveLikeCommentReport(id: UUID!): LiveLikeCommentReport
  createLiveLikeChatRoom(input: LiveLikeChatRoomCreateInput!): LiveLikeChatRoom
  updateLiveLikeChatRoom(input: LiveLikeChatRoomUpdateInput!): LiveLikeChatRoom
  deleteLiveLikeChatRoom(id: UUID!): Boolean
  createLiveLikeRewardItem(input: LiveLikeRewardItemCreateInput!): LiveLikeRewardItem

  """
  Credit reward item points to a user profile.
  Returns the resulting RewardItemTransaction.
  """
  creditLiveLikeRewardItem(input: LiveLikeRewardItemTransactionInput!): LiveLikeRewardItemTransaction

  """
  Debit reward item points from a user profile.
  Returns the resulting RewardItemTransaction.
  """
  debitLiveLikeRewardItem(input: LiveLikeRewardItemTransactionInput!): LiveLikeRewardItemTransaction
  deleteLiveLikeRewardItem(id: UUID!): Boolean
  createLiveLikeRewardTable(input: LiveLikeRewardTableCreateInput!): LiveLikeRewardTable
  updateLiveLikeRewardTable(input: LiveLikeRewardTableUpdateInput!): LiveLikeRewardTable
  deleteLiveLikeRewardTable(id: UUID!): Boolean
  createLiveLikeRewardTableEntry(input: LiveLikeRewardTableEntryCreateInput!): LiveLikeRewardTableEntry
  deleteLiveLikeRewardTableEntry(input: LiveLikeRewardTableEntryDeleteInput!): Boolean
  linkLiveLikeRewardTableWithProgram(input: LiveLikeLinkRewardTableWithProgramInput!): Boolean
  unlinkLiveLikeRewardTableWithProgram(input: LiveLikeUnlinkRewardTableWithProgramInput!): Boolean
  invokeLiveLikeRewardAction(input: LiveLikeRewardActionCreateInput!): LiveLikeRewardAction
  createLiveLikeLeaderboard(input: LiveLikeLeaderboardCreateInput!): LiveLikeLeaderboard
  updateLiveLikeLeaderboard(input: LiveLikeLeaderboardUpdateInput!): LiveLikeLeaderboard
  deleteLiveLikeLeaderboard(id: UUID!): Boolean
  linkLiveLikeLeaderboardWithProgram(input: LiveLikeLeaderboardProgramLinkInput!): Boolean
  unlinkLiveLikeLeaderboardFromProgram(input: LiveLikeLeaderboardProgramLinkInput!): Boolean
  awardLiveLikeBadge(input: LiveLikeAwardBadgeInput!): LiveLikeEarnedBadge
  revokeLiveLikeEarnedBadge(earnedBadgeId: UUID!): Boolean
  createLiveLikeProgramBan(input: LiveLikeProgramBanInput!): LiveLikeProgramBan
  deleteLiveLikeProgramBan(id: UUID!): Boolean
  createLiveLikeCommentBoardBan(input: LiveLikeCommentBoardBanInput!): LiveLikeCommentBoardBan
  deleteLiveLikeCommentBoardBan(id: UUID!): Boolean
  createLiveLikeQuest(input: LiveLikeQuestInput!): LiveLikeQuest
  createLiveLikeUserQuest(input: LiveLikeUserQuestInput!): LiveLikeUserQuest
  updateLiveLikeUserQuestTaskProgress(input: LiveLikeUserQuestsTaskProgressInput!): LiveLikeUserQuestTaskProgress
  claimLiveLikeUserQuestReward(input: LiveLikeclaimUserQuestRewardInput!): LiveLikeUserQuest

  """Send Push Notification for specific tenant to provided tag ids"""
  sendPushNotification(tenant: Tenant!, notification: NewPushNotification!): PushNotification

  """Add new Device for specific tenant"""
  addDevice(tenant: Tenant!, device: DeviceInput!): Device
  addPushNotificationsAlertRank(tenant: Tenant!, alertRankInput: PushNotificationAlertRankInput): PushNotificationAlertRankResponse
  addAlertRank(tenant: Tenant!, alertRankInput: AddAlertRankInput): AddAlertRankResponse
  prepareImage(tenant: Tenant!, imageCount: Int!, imageTypes: ImageTypes!): PrepareImageResponse
  createPostByTenant(tenant: Tenant!, post: PostInput!): CreatePostResponse
  updatePostByTenant(tenant: Tenant!, post: UpdatePostInput!): CreatePostResponse
  createTextPollByTenant(tenant: Tenant!, poll: TextPollInput!): CreatePollResponse
  updateTextPollByTenant(tenant: Tenant!, poll: UpdateTextPollInput!): CreatePollResponse
  createImagePollByTenant(tenant: Tenant!, poll: ImagePollInput!): CreatePollResponse
  createProgramForTaxonomy(tenant: Tenant!, taxonomyId: String!): CreateProgramResponse
  addUserTags(inputs: [UserTagInput]!, tenant: Tenant!): [TagV2]
  removeUserTags(tagUUIDS: [String]!, tenant: Tenant!): [TagV2]
  updateUserTags(inputs: [UserTagInput]!, tenant: Tenant!): [TagV2]
  setUserSpoilers(tagUUID: String!, spoilers: Boolean!, tenant: Tenant!): TagV2 @deprecated(reason: "Use updateUserTags with spoilers in the notifications array instead")
  setUserFavoriteTeams(tagUUIDS: [String]!, tenant: Tenant!): User
  blockProfile(blockedProfileID: String!): blockProfileResponse
  unblockProfile(blockedProfileID: String!): Boolean
  setGlobalSpoilerSettings(spoilersEnabled: Boolean!): Settings @deprecated(reason: "Use setGlobalAlerts with spoilers alerts instead")
  setGlobalAlerts(input: [AlertInput]!): Settings
}

type Name {
  first: String
  last: String
  display_name: String
}

type NavigationElement {
  name: String
  href: String @deprecated(reason: "Use queryParameters instead")
  queryParameters: NavigationQueryParameters
}

type NavigationQueryParameters {
  date: String
  league: StatsLeagues
}

input NewPushNotification {
  """Add ad parameters"""
  adParameters: String

  """
  Provides a list of genres for Analytics, cannot be null, needs at least one
  """
  analytics: AlertAnalyticsInput!

  """These are the list of the attachments related to the alert"""
  attachments: [AlertMediaAttachmentInput!]!

  """This would be a list of the allowed regions the alert can be sent to"""
  allowInRegions: [AlertRegion!]!

  """This would keep track of the places the alert will be going to"""
  destinations: [AlertDestinationInput!]!

  """
  This would be an override destination. If provided, all users will receive this common destination.
  Otherwise, the users will receive the destination included with the tagId they are subscribed to which
  is included in the destinations list above. The String is the contentModule ID.
  """
  destinationOverride: String

  """This is the ID of the user that created the alert"""
  createdBy: ID!

  """Mobile uses to show alert card"""
  showAlertCard: Boolean

  """This is the alert type to know which category it falls into"""
  alertCategories: [AlertCategory]!

  """This will let us know if it is a spoiler or not"""
  spoiler: Boolean

  """Push Notification's text message"""
  text: String = ""

  """Push Notification's title message"""
  title: String = ""

  """Url of content, could be null"""
  url: String
}

"""A string that cannot be passed as an empty value"""
scalar NonEmptyString

"""Floats that will have a value of 0 or more."""
scalar NonNegativeFloat

"""Integers that will have a value of 0 or more."""
scalar NonNegativeInt

input NotificationInput {
  id: Category!
  notificationMethods: [NotificationMethodInput]
}

type NotificationMethod {
  type: CategoryType
  enabled: Boolean
}

input NotificationMethodInput {
  type: CategoryType!
  enabled: Boolean!
}

type Notifications {
  id: Category
  notificationMethods: [NotificationMethod]
  enabled: Boolean
}

type Offering {
  id: String
  contentClass: String
  contentId: String
  editId: String
  actions: Action
  alternateIds: [Identifier]
  appNames: VideoAppName
  brands: [Brand]
  limitations: Limitation
  packages: [String]
  platforms: AllowAll
  productLines: [ProductLine]
  territories: [String]
  startDate: String
  createdDateTime: String
  endDate: String
  firstAvailableDate: String
  lastModifiedDateTime: String
}

input PackageContent {
  contentId: ID
  contentType: ContentModuleType
  thumbnailAccreditation: String
  thumbnailCopyright: String
  title: String!
  description: String!
  thumbnail: String!
  orientation: ModuleOrientation
  allowedCountries: [String]
  positionLockExpiresAt: Date
  isPositionLocked: Boolean
  position: Int
  contentModuleId: ID
  updateProgrammingTimestamp: Boolean
  scheduledDate: Date
  expiresAt: Date
  hidden: Boolean
  hiddenExpiresAt: Date
}

type PackageContentModule implements ContentModule {
  id: ID!

  """
  Metadata containing community tag, author, and brand information for logos and display.
  """
  metaData: ModuleMetaData

  """Ads Configuration | Ads API"""
  adsConfig: AdsConfiguration

  """Also known as Headline, that's the heading text of a content module."""
  title: String!

  """
  Also known as Commentary, short description of the content of a content module.
  """
  description: String!

  """packageTag of composite data"""
  packageTag: String

  """Unique title for the package content module"""
  uniqueTitle: String

  """Package headline for the content module"""
  packageHeadline: String

  """
  Type of the package, defines if a package is one of the static package or ad hoc.
  """
  packageType: PackageType

  """Type of the content that will be accepted by the package."""
  contentType: ContentModuleType

  """List of contents of the package."""
  contents: [StandaloneContentModule]

  """Content module orientation, one of: Landscape or Portrait"""
  orientation: ModuleOrientation!

  """
  Date and Time when a content module will not be visible anymore for end users. The state will be `UNPROGRAMMED`.
  """
  expiresAt: Date

  """
  Date and Time when a content module will start to be visible for end users. The state will be `SCHEDULED`.
  """
  scheduledDate: Date

  """
  List of possible states of content module. One of `SCHEDULED`, `PROGRAMMED` or `UNPROGRAMMED`.
  """
  state: ModuleState

  """
  List of Channels/Components (tag + semanticID) a content module is programmed to.
  """
  components: [ComponentModule]

  """Indicates if a push notification was sent to the content module."""
  isAlerted: Boolean

  """List of countries that a content module will be visible."""
  allowedCountries: [String]
  commentsEnabled: Boolean

  """Indicates to what tagUUID the content module was alerted to."""
  alertedChannelTagUUID: String

  """Date and time that a content module was last updated."""
  updatedAt: Date

  """Date and time that the Content Modules was created"""
  insertedAt: Date
  hidden: Boolean

  """
  Date and Time when a hidden content module will automatically become visible again.
  """
  hiddenExpiresAt: Date
  alertRanks(limit: Int = 10): [AlertRank]!
}

input PackageInput {
  contentModuleId: ID
  lastModifiedBy: String!
  channels: [TagComponent!]!
  title: String!
  contentType: ContentModuleType!
  expiresAt: Date
  description: String
  packageType: PackageType
  allowedCountries: [String]
  commentsEnabled: Boolean
  packageTag: String
  scheduledDate: Date
  uniqueTitle: String
  packageHeadline: String
  hidden: Boolean
  hiddenExpiresAt: Date
}

enum PackageType {
  TopHeadlines
  TrendingVideos
  WhatsBuzzing
  CreatorShows
  FromTheFans
  AdHoc
  TrendingBets
  Highlights
  HomeLandscape
  HomePortrait
}

type Page {
  _id: MongoID!
  uuid: String!
  tenant: String

  """Ads Configuration | Ads API"""
  adsConfig: AdsConfiguration
  schemaVersion: String
  cmsId: String!
  isPublished: Boolean
  language: String
  type: String
  uri: String!
  title: String
  headline: String
  body: PageBody
  created: String
  changed: String
  metatags: [PageMetatags]
  components: [Component] @deprecated(reason: "This field will be removed. Please use the \"componentsConnection\" field which provides support for component pagination")
  componentsConnection(before: ComponentCursor, after: ComponentCursor, first: Int, last: Int): ComponentsConnection!
}

type PageBody {
  value: String
  summary: String
  format: String
  _id: MongoID
}

input PageComponentFiltersInput {
  """
  Filter Page Components by a User's favorite Team. Value passed should be **sportradar_id** (ex. `sr:competitor:1234`)
  """
  team: String
}

"""  PageInfo in this context provides metadata for **pagination** It is not related to the Page type.
"""
type PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String
  endCursor: String
}

type PageMetatags {
  type: String
  key: String
  content: String
  _id: MongoID
}

input PaginationControl {
  semanticId: String!
  first: Int
  last: Int
  before: ContentCursor
  after: ContentCursor
}

input PaginationControlInput {
  after: ComponentCursor
  before: ComponentCursor
  first: Int
  last: Int
}

type PeriodScore {
  """
  Number of the period - potentially used in conjunction with `type` for constructing a column header ("Set 1")
  """
  number: Int

  """Primary Score Value"""
  score: String

  """Secondary Score Value (example: tiebreaks in tennis)"""
  subscore: String

  """Type of period - will vary by sport"""
  type: PeriodScoreType
}

enum PeriodScoreType {
  TennisSet
}

type Playlist {
  schemaVersion: String
  tenant: String
  uuid: String!
  cmsId: String!
  isPublished: Boolean
  language: String
  title: String
  headline: String
  type: String
  created: String
  changed: String
  tagging: Tagging
  media: [Media]
  _id: MongoID!
}

type Poll {
  id: ID!
  contentId: ID!
}

"""Integers that will have a value greater than 0."""
scalar PositiveInt

type Post {
  id: ID!
  contentId: ID
  content: String!
}

input PostInput {
  uploadId: ID
  content: String!
  tagUUIDs: [String!]!
}

type PrepareImageResponse {
  uploadId: ID!
  errorMsg: String
  urlMappings: [UrlMapping!]!
}

type Product {
  weight: Float
  productId: String
  cta: String
  price: String
  headline: String
  subHeadline: String
  disclaimer: String
  isPayPalEnabled: Boolean
  _id: MongoID
}

type ProductLine {
  id: Identifier
  label: String
}

type Program {
  id: String
  entityClass: String
  entityType: String
  titles: [VideoTitle]
  alternateIds: [Identifier]
  credits: [Credit]
  ratings: [Rating]
  taxonomyReferenceGroups: [TaxonomyReferenceGroup]
  createdDateTime: String
  lastModifiedDateTime: String
}

union ProgrammedContent = Article | ExternalArticle | StatsBetting | StatsGamecast | Tweet | VideoV2 | UGCImagePoll | UGCPost | UGCTextPoll

type PushNotification {
  """Push Notification ID"""
  id: ID!

  """When Push Notification was created at"""
  createdAt: DateTime!

  """Add ad parameters"""
  adParameters: String

  """
  Provides a list of genres for Analytics, cannot be null, needs at least one
  """
  analytics: AlertAnalytics

  """These are the list of the attachments related to the alert"""
  attachments: [AlertMediaAttachment!]!

  """This would be a list of the allowed regions the alert can be sent to"""
  allowInRegions: [AlertRegion!]!

  """This would keep track of the places the alert will be going to"""
  destinations: [AlertDestination!]!

  """
  The resolved destination for an individual alert instance sent to a specific user
  """
  userDestination: UserDestination

  """
  This would be an override destination. If provided, all users will receive this common destination.
  Otherwise, the users will receive the destination included with the tagId they are subscribed to which
  is included in the destinations list above. The String is the contentModule ID.
  """
  destinationOverride: String

  """This is the ID of the user that created the alert"""
  createdBy: ID!

  """Mobile uses to show alert card"""
  showAlertCard: Boolean

  """This is the alert type to know which category it falls into"""
  alertCategories: [AlertCategory!]!

  """This will let us know if it is a spoiler or not"""
  spoiler: Boolean

  """The tag ids that will receive the Push Notification"""
  tags: [TagV2!]!

  """Push Notification's text message"""
  text: String!

  """Push Notification's title"""
  title: String!
  url: String!
}

input PushNotificationAlertRankInput {
  alertRanks: [AlertRankInput!]
}

type PushNotificationAlertRankResponse {
  status: String!
  message: String
}

"""TEST Query the Hydration Station Social Entities"""
type Query {
  """getArticleByCmsId | CMS API"""
  getArticleByCmsId(cmsId: String, tenant: Tenant!, publishedOnly: Boolean = true): Article

  """getArticleByUUID | CMS API"""
  getArticleByUUID(uuid: String, tenant: Tenant!, publishedOnly: Boolean = true): Article

  """getArticleByDisplayId | CMS API"""
  getArticleByDisplayId(
    """The display id of the article"""
    displayId: Int!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): Article

  """getArticleBySlug | CMS API"""
  getArticleBySlug(slug: String, tenant: Tenant!, publishedOnly: Boolean = true): Article

  """getAllArticles | CMS API"""
  getAllArticles(tenant: Tenant!, publishedOnly: Boolean = true, before: String, after: String, limit: Int, skip: Int, searchParams: ArticleFindManyParametersInput, sort: ContentLibrarySortParametersInput): ArticleConnection

  """getAllVideos | CMS API"""
  getAllVideos(limit: Int = 25, order: String = "asc", skip: Int = 0, videoFilters: VideoFiltersInput, tenant: Tenant!, publishedOnly: Boolean = true): [Video]

  """getVideosByEventId | CMS API"""
  getVideosByEventId(
    """
    The expected value is the Sport Radar ID of the Event (ex. `sr:match:1234`).
    """
    eventId: String
    limit: Int = 25
    order: String = "asc"
    skip: Int = 0
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): [Video]

  """getVideoById | CMS API"""
  getVideoById(id: String, tenant: Tenant!, publishedOnly: Boolean = true): Video

  """getVideoByCmsId | CMS API"""
  getVideoByCmsId(cmsId: String, limit: Int = 25, skip: Int = 0, tenant: Tenant!, publishedOnly: Boolean = true): Video

  """getVideosByTeamId | CMS API"""
  getVideosByTeamId(
    """
    The expected value is the Sport Radar ID of the Team (ex. `sr:competitor:1234`).
    """
    teamId: String
    limit: Int = 25
    order: String = "desc"
    skip: Int = 0
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): [Video]

  """getPageByUri | CMS API"""
  getPageByUri(uri: String!, componentFilters: PageComponentFiltersInput, tenant: Tenant!, publishedOnly: Boolean = true): Page

  """getAllPlaylists | CMS API"""
  getAllPlaylists(tenant: Tenant!, publishedOnly: Boolean = true): [Playlist]

  """getPlaylistById | CMS API"""
  getPlaylistById(id: String, tenant: Tenant!, publishedOnly: Boolean = true): Playlist

  """getPlaylistByCmsId | CMS API"""
  getPlaylistByCmsId(cmsId: String, tenant: Tenant!, publishedOnly: Boolean = true): Playlist

  """getPlaylistByEventId | CMS API"""
  getPlaylistByEventId(
    tenant: Tenant!

    """
    The expected value is the Sport Radar ID of the Event (ex. `sr:match:123`). **NOT** the LET ID.
    """
    eventId: String
    publishedOnly: Boolean = true
  ): Playlist

  """getTaxonomyByIdAndType | CMS API"""
  getTaxonomyByIdAndType(id: String!, type: TaxonomyType!, tenant: Tenant!, publishedOnly: Boolean = true): TaxonomyTerm

  """getAllMenus | CMS API"""
  getAllMenus(tenant: Tenant!, publishedOnly: Boolean = true): [Menu]

  """getMenuById | CMS API"""
  getMenuById(
    """The **text** ID of the Menu. This is an ID such as `main` or `footer`."""
    id: String
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): Menu

  """getConfigJsonByUri | CMS API"""
  getConfigJsonByUri(uri: String!, tenant: Tenant!, publishedOnly: Boolean = true): ConfigJson

  """getTagByForeignId | CMS API"""
  getTagByForeignId(
    """The foreign ID to look up matching tags"""
    foreignId: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): TagV2

  """getTagByForeignIds | CMS API"""
  getTagByForeignIds(
    """A list of foreign IDs to look up matching tags"""
    foreignIds: [String!]!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): [TagV2]

  """getTagByUUID | CMS API"""
  getTagByUUID(
    """The UUID of the Tag"""
    uuid: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): TagV2

  """getTagBySlugs | CMS API"""
  getTagBySlugs(
    """A list of slugs to lookup matching tags"""
    slugs: [String!]!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): [TagV2]

  """tags | CMS API"""
  tags(tagParams: TagsQueryInput!, paginationControl: PaginationControlInput, tenant: Tenant!, publishedOnly: Boolean = true): TagV2Connection

  """getTagGroupByUUID | CMS API"""
  getTagGroupByUUID(
    """The UUID of the Tag Group"""
    uuid: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): TagGroup

  """getTagGroupsBySlugs | CMS API"""
  getTagGroupsBySlugs(
    """A list of slugs to lookup matching tag groups"""
    slugs: [String!]!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): [TagGroup]

  """getChannelByCmsId | CMS API"""
  getChannelByCmsId(cmsId: String, tenant: Tenant!, publishedOnly: Boolean = true): Channel

  """getChannelByTagUUID | CMS API"""
  getChannelByTagUUID(
    """The UUID of the Tag (TagV2) of the Channel"""
    tagUUID: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): Channel

  """getChannelByUUID | CMS API"""
  getChannelByUUID(
    """The UUID of the Channel"""
    uuid: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): Channel

  """getChannelBySlug | CMS API"""
  getChannelBySlug(
    """The slug of the Tag (TagV2) of the Channel"""
    slug: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): Channel

  """getAllVideosV2 | CMS API"""
  getAllVideosV2(playable: Boolean, contentType: VideoContentType, videoType: VideoType, tag: String, tenant: Tenant!, publishedOnly: Boolean = true): [VideoV2]

  """getVideoV2ByCmsId | CMS API"""
  getVideoV2ByCmsId(cmsId: String, tenant: Tenant!, publishedOnly: Boolean = true): VideoV2

  """getVideoV2ById | CMS API"""
  getVideoV2ById(
    """Search by eventId"""
    eventId: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): VideoV2

  """getVideoV2ByEditId | CMS API"""
  getVideoV2ByEditId(
    """search by Offering.editId"""
    editId: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): VideoV2

  """getVideoV2TagIdsFromEventIds | CMS API"""
  getVideoV2TagIdsFromEventIds(
    """List of VideoV2 eventIds to resolve tag ids for"""
    eventIds: [String!]!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): [VideoV2TagIds!] @deprecated(reason: "No longer in use")

  """searchTagByMatchTerm | CMS API"""
  searchTagByMatchTerm(searchParams: TagSearchParamsInput, tenant: Tenant!, publishedOnly: Boolean = true): [TagV2!]!

  """searchContentLibrary | CMS API"""
  searchContentLibrary(tenant: Tenant!, publishedOnly: Boolean = true, searchParams: ContentLibrarySearchParametersInput, sort: ContentLibrarySortParametersInput): [ContentLibrarySearchResult]

  """findContentBrandBySourceUrl | CMS API"""
  findContentBrandBySourceUrl(
    """
    The source identifier (typically a base url such as si.com) to find a matching ContentBrand for
    """
    source: String!
    tenant: Tenant!
    publishedOnly: Boolean = true
  ): ContentBrand
  getHelloWorld: String @deprecated(reason: "No longer needed")
  contentModules: [ContentModule]
  fetchContentModuleById(id: ID!): ContentModule
  fetchContentModuleByContentIdAndContentType(contentId: ID!, contentType: String!, state: [ModuleState] = [PROGRAMMED]): [ContentModule]!
  fetchPackageByTypeAndTag(packageType: String!, tagUUID: String!, state: [ModuleState] = [PROGRAMMED]): [PackageContentModule]
  findPackageByTitle(title: String, state: [ModuleState] = [PROGRAMMED]): [PackageContentModule]
  findContentModulesBySemanticIdAndTag(tagUUID: String, semanticID: SemanticID, state: [ModuleState] = [PROGRAMMED], limit: Int = 150, tagSlug: String): [ContentModule]
  paginatedFindContentModulesBySemanticIdAndTag(
    tagUUID: String
    semanticID: SemanticID
    first: Int
    after: ContentCursor
    last: Int
    before: ContentCursor

    """
    A list of States to filter content modules by. Default value: PROGRAMMED
    """
    state: [ModuleState] = [PROGRAMMED]
  ): ContentsConnection @deprecated(reason: "This query will soon be removed in favor of paginated version of findContentModulesBySemanticIdAndTag")
  fetchScheduledModules(startDate: Date, endDate: Date, limit: Int): [ContentModule]
  dsModel(model: String!): DsModel
  trendingChannels(topN: Int!): [TrendingChannelResult!]!
  trendingArticles(topN: Int!, primaryPrioritizedTag: String = null, secondaryPrioritizedTags: [String!]! = []): [TrendingResult!]!
  trendingVideos(topN: Int!, countryCode: String, aspectRatio: AspectRatio = Any, primaryPrioritizedTag: String = null, secondaryPrioritizedTags: [String!]! = []): [TrendingResult!]!
  a2v(articleUuid: String!, countryCode: String, version: Int = 0, aspectRatio: AspectRatio = Any, limit: Int = 10, primaryPrioritizedTag: String = null, secondaryPrioritizedTags: [String!]! = []): [A2VResult!]!
  a2a(articleUuid: String!, version: Int = 0, limit: Int = 10, primaryPrioritizedTag: String = null, secondaryPrioritizedTags: [String!]! = []): [A2AResult!]!
  v2v(videoEventId: String!, countryCode: String, version: Int = 0, aspectRatio: AspectRatio = Any, limit: Int = 10, primaryPrioritizedTag: String = null, secondaryPrioritizedTags: [String!]! = []): [V2VResult!]!
  articleBlocklist(sinceDate: Date, beforeDate: Date, limit: Int = 10): [BlockedContent!]!
  videoBlocklist(sinceDate: Date, beforeDate: Date, limit: Int = 10): [BlockedContent!]!
  alertRanks(limit: Int = 10, offset: Int = 0): [AlertRank!]!

  """getScheduleByFeeds | Episode API | EPG API"""
  getScheduleByFeeds(feed: Feeds!, from: String, to: String, count: Int): Schedule

  """
  getAllCompetitors | Will be deprecated February 01, 2023 | Use getCompetitorList
  """
  getAllCompetitors(has_media: Boolean, territories: Territories, tenant: Tenants!): [Competitor]

  """getCompetitorList | Event API | LET API"""
  getCompetitorList(has_media: Boolean, territories: Territories, tenant: Tenants!, count_start: Int, count_end: Int): Competitors

  """getCompetitorById | Event API | LET API"""
  getCompetitorById(id: String!, tenant: Tenants!): Competitor

  """
  getAllConferences | Will be deprecated February 01, 2023 | Use getConferenceList
  """
  getAllConferences(tenant: Tenants!): [Conference]

  """getConferenceList | Event API | LET API"""
  getConferenceList(tenant: Tenants!, count_start: Int, count_end: Int): Conferences

  """getConferenceById | Event API | LET API"""
  getConferenceById(id: String!, tenant: Tenants!): Conference

  """
  getAllDivisions | Will be deprecated February 01, 2023 | Use getDivisionList
  """
  getAllDivisions(tenant: Tenants!): [Division]

  """getDivisionList | Event API | LET API"""
  getDivisionList(tenant: Tenants!, count_start: Int, count_end: Int): Divisions

  """getDivisionById | Event API | LET API"""
  getDivisionById(id: String!, tenant: Tenants!): Division

  """getAllEvents | Will be deprecated February 01, 2023 | Use getEventList"""
  getAllEvents(start_date: String, end_date: String, count_start: String, count_end: String, sort: EventSort, order: SortDirections, media_filter: String, has_media: Boolean, season: Int, territories: Territories, type: EventTypes, tenant: Tenants!, filterId: [EventFilterType]): [Event]

  """getEventList | Event API | LET API"""
  getEventList(start_date: String, end_date: String, count_start: String, count_end: String, sort: EventSort, order: SortDirections, media_filter: String, has_media: Boolean, season: Int, territories: Territories, type: EventTypes, tenant: Tenants!, filterId: [EventFilterType]): Events

  """getEventById | Event API | LET API"""
  getEventById(id: String!, tenant: Tenants!, isSportRadar: Boolean = false): Event

  """
  getAllLeagues | Will be deprecated February 01, 2023 | Use getLeagueList
  """
  getAllLeagues(has_media: Boolean, territories: Territories, tenant: Tenants!): [League]

  """getLeagueList | Event API | LET API"""
  getLeagueList(has_media: Boolean, territories: Territories, tenant: Tenants!, count_start: Int, count_end: Int): Leagues

  """getLeagueById | Event API | LET API"""
  getLeagueById(id: String!, tenant: Tenants!): League

  """
  getAllSeries | Will be deprecated February 01, 2023 | Use getSeriesList
  """
  getAllSeries(has_media: Boolean, territories: Territories, tenant: Tenants!, tournament_id: String, competitor_id: String, season: String, sort: SeriesSort, order: SortDirections): [Series]

  """getSeriesList | Event API | LET API"""
  getSeriesList(has_media: Boolean, territories: Territories, tenant: Tenants!, tournament_id: String, competitor_id: String, season: String, sort: SeriesSort, order: SortDirections, count_start: Int, count_end: Int): Serieses

  """getSeriesById | Event API | LET API"""
  getSeriesById(id: String!, tenant: Tenants!): Series

  """getAllSports | Will be deprecated February 01, 2023 | Use getSportList"""
  getAllSports(tenant: Tenants!): [Sport]

  """getSportList | Event API | LET API"""
  getSportList(tenant: Tenants!, count_start: Int, count_end: Int): Sports

  """getSportById | Event API | LET API"""
  getSportById(id: String!, tenant: Tenants!): Sport

  """
  getAllTournaments | Will be deprecated February 01, 2023 | Use getTournamentList
  """
  getAllTournaments(has_media: Boolean, territories: Territories, tenant: Tenants!): [Tournament]

  """getTournamentList | Event API | LET API"""
  getTournamentList(has_media: Boolean, territories: Territories, tenant: Tenants!, count_start: Int, count_end: Int): Tournaments

  """getTournamentById | Event API | LET API"""
  getTournamentById(id: String!, tenant: Tenants!): Tournament

  """getAllVenues | To be deprecated December, 2022"""
  getAllVenues(tenant: Tenants!): [Venue]

  """
  getVenueList | Event API | LET API | Includes Pagination (Use instead of getAllVenues)
  """
  getVenueList(tenant: Tenants!, count_start: Int, count_end: Int): Venues

  """getVenueById | Event API | LET API"""
  getVenueById(id: String!, tenant: Tenants!): Venue
  getMetadata: Metadata

  """
  TEST Query for fetching Tweets from Hydration Station no used in Production Clients ONLY DEV
  """
  getTweetsByIds(ids: [ID!]!): [Tweet!]!
  liveLikeMe: LiveLikeProfile
  liveLikeProfile(id: UUID!): LiveLikeProfile
  liveLikeProfileByCustomId(input: LiveLikeProfileGetByCustomIdInput!): LiveLikeProfile
  liveLikeBlockedProfileIds: [UUID!]
  liveLikeProfileRelationshipType(id: UUID!): LiveLikeProfileRelationshipType
  liveLikeProfileRelationshipTypes(input: LiveLikeProfileRelationshipTypesInput!): LiveLikeProfileRelationshipTypeCollection
  liveLikeProfileRelationships(input: LiveLikeProfileRelationshipInput!, order: LiveLikeProfileRelationshipOrderInput): LiveLikeProfileRelationshipCollection
  liveLikePermissions(page: PositiveInt): LiveLikePermissions
  liveLikeRoles(input: LiveLikeRolesGetInput!): LiveLikeRoleConnection
  liveLikeRolesAssignment(input: LiveLikeRoleAssignmentsGetInput!): LiveLikeRoleAssignmentConnection
  liveLikeApplication(clientId: NonEmptyString!): LiveLikeApplication
  liveLikeProgram(id: UUID!): LiveLikeProgram
  liveLikeProgramByCustomId(input: LiveLikeProgramGetByCustomIdInput!): LiveLikeProgram
  liveLikePrograms(input: LiveLikeProgramsGetInput!): LiveLikeProgramConnection
  liveLikeWidgets(programId: UUID!, input: LiveLikeWidgetGetInput, order: LiveLikeWidgetOrderInput): LiveLikeWidgetCollection
  liveLikeWidgetsInteractions(profileId: UUID!, input: [LiveLikeWidgetInteractionsInput!]!): [LiveLikeWidgetInteractions!]
  liveLikeWidgetReports(input: LiveLikeWidgetReportsInput): LiveLikeWidgetReportCollection
  liveLikeTextPoll(id: UUID!): LiveLikeTextPoll
  liveLikeImagePoll(id: UUID!): LiveLikeImagePoll
  liveLikeRichPost(id: UUID!): LiveLikeRichPost

  """
  Fetch the text quiz widget with the id.
  Returns the TextQuiz object.
  """
  liveLikeTextQuiz(id: UUID!): LiveLikeTextQuiz

  """
  Fetch the image quiz widget with the id.
  Returns the ImageQuiz object.
  """
  liveLikeImageQuiz(id: UUID!): LiveLikeImageQuiz

  """
  Fetch the text prediction widget with the id.
  Returns the TextPrediction object.
  """
  liveLikeTextPrediction(id: UUID!): LiveLikeTextPrediction

  """
  Fetch the text prediction follow up widget with the id.
  Returns the TextPredictionFollowUp object.
  """
  liveLikeTextPredictionFollowUp(id: UUID!): LiveLikeTextPredictionFollowUp

  """
  Fetch the image prediction widget with the id.
  Returns the ImagePrediction object.
  """
  liveLikeImagePrediction(id: UUID!): LiveLikeImagePrediction

  """
  Fetch the image prediction follow up widget with the id.
  Returns the ImagePredictionFollowUp object.
  """
  liveLikeImagePredictionFollowUp(id: UUID!): LiveLikeImagePredictionFollowUp

  """ Get a Alert widget by ID """
  liveLikeAlert(id: UUID!): LiveLikeAlert

  """ Get a Video Alert widget by ID """
  liveLikeVideoAlert(id: UUID!): LiveLikeVideoAlert

  """ Get a Social Embed widget by ID """
  liveLikeSocialEmbed(id: UUID!): LiveLikeSocialEmbed
  liveLikeReactionPack(id: UUID!): LiveLikeReactionPack
  liveLikeReactionPacks(input: LiveLikeReactionPacksGetInput!): LiveLikeReactionPackCollection
  liveLikeReactionSpace(id: UUID!): LiveLikeReactionSpace
  liveLikeReactionSpaces(input: LiveLikeReactionSpaceGetInput!): LiveLikeReactionSpaceCollection
  liveLikeReactionSpacesCount(input: LiveLikeReactionSpacesCountInput!): [LiveLikeReactionSpaceCount!]
  liveLikeUserReactions(input: LiveLikeUserReactionsGetInput!): LiveLikeUserReactionCollection
  liveLikeUserReactionCounts(input: LiveLikeUserReactionCountsGetInput!): LiveLikeUserReactionCountCollection
  liveLikeCommentBoard(id: UUID!): LiveLikeCommentBoard
  liveLikeCommentBoards(input: LiveLikeCommentBoardsGetInput!): LiveLikeCommentBoardCollection
  liveLikeCommentBoardsCount(input: LiveLikeCommentBoardsCountGetInput!): [LiveLikeCommentBoardCount!]
  liveLikeComment(id: UUID!): LiveLikeComment
  liveLikeComments(input: LiveLikeCommentsGetInput!): LiveLikeCommentCollection
  liveLikeCommentReplies(input: LiveLikeCommentRepliesGetInput!): LiveLikeCommentCollection
  liveLikeCommentReport(id: UUID!): LiveLikeCommentReport
  liveLikeCommentsReports(input: LiveLikeCommentsReportsGetInput!): LiveLikeCommentReportCollection
  liveLikeChatRoom(id: UUID!): LiveLikeChatRoom
  liveLikeChatRooms(input: LiveLikeChatRoomsGetInput!): LiveLikeChatRoomCollection
  liveLikeRewardItem(id: UUID!): LiveLikeRewardItem
  liveLikeRewardItems(clientId: NonEmptyString!): LiveLikeRewardItemCollection
  liveLikeRewardTable(id: UUID!): LiveLikeRewardTable
  liveLikeRewardTables(input: LiveLikeRewardTablesGetInput!): LiveLikeRewardTableCollection
  liveLikeRewardTableEntry(input: LiveLikeRewardTableEntryGetInput!): LiveLikeRewardTableEntry
  liveLikeRewardBalance(profileId: UUID!, input: LiveLikeRewardBalanceGetInput!): LiveLikeRewardItemBalance
  liveLikeRewardBalances(profileId: UUID!, input: LiveLikeRewardBalancesGetInput): LiveLikeRewardItemBalanceCollection
  liveLikeLeaderboard(id: UUID!): LiveLikeLeaderboard
  liveLikeLeaderboards(input: LiveLikeLeaderboardsGetInput!): LiveLikeLeaderboardCollection
  liveLikeLeaderboardEntry(input: LiveLikeLeaderboardEntryGetInput!): LiveLikeLeaderboardEntry
  liveLikeLeaderboardEntries(input: LiveLikeLeaderboardEntriesGetInput!): LiveLikeLeaderboardEntryCollection
  liveLikeBadge(id: UUID!): LiveLikeBadge
  liveLikeBadges(clientId: NonEmptyString!): LiveLikeBadgeCollection
  liveLikeBadgeProfiles(badgeId: UUID!): LiveLikeBadgeProfileCollection
  liveLikeBadgeProgress(profileId: UUID!, badgeId: UUID!): [LiveLikeBadgeRewardProgressCollection!]
  liveLikeEarnedBadges(profileId: UUID!): LiveLikeEarnedBadgeCollection
  liveLikeUserBadges(page: PositiveInt): LiveLikeUserBadgeCollection
  liveLikeProgramBans(input: LiveLikeProgramBansInput): LiveLikeProgramBanCollection
  liveLikeCommentBoardBan(id: UUID!): LiveLikeCommentBoardBan
  liveLikeCommentBoardBans(input: LiveLikeCommentBoardBansInput): LiveLikeCommentBoardBanCollection
  liveLikeQuests(clientId: NonEmptyString!): LiveLikeQuestCollection
  liveLikeUserQuests(profileId: UUID!, input: LiveLikeUserQuestsInput): LiveLikeUserQuestCollection
  liveLikeUserQuestRewards(input: LiveLikeUserQuestRewardsInput!): LiveLikeUserQuestRewardsConnection

  """Get the User's Push Notifications"""
  getUserPushNotifications(limit: Int = 50, tenant: Tenant!): [PushNotification!]!

  """
  Returns contentModuleIds that have been push notifications associated with them.
  """
  getContentModuleIdsWithPushNotificationIds(contentModuleIds: [String!]!, tenant: Tenant!): [Int!]

  """Get all push notifications."""
  getAllNotifications(limit: Int = 50, tenant: Tenant!, lastPushNotificationId: Int, latestUnixTimestamp: Int): [PushNotification!]!

  """Get one push notification by id."""
  getPushNotificationById(id: ID!, tenant: Tenant!): PushNotification

  """Grab references by name with optional limit"""
  getReferenceStreamByName(referenceStreamName: String!, limit: Int): [Reference!] @deprecated(reason: "Use `getReferenceStreamByComponentId` instead.")

  """Grab reference stream by name with optional limit"""
  getReferenceStreamByComponentId(componentID: String!, limit: Int): ReferenceStream
  getMediaId(id: String): String
  popularSearches(tenant: Tenant!, first: Int, filterTerms: String): QueryAssistResponse!
  search(after: String, algorithm: String, tenant: Tenant!, contentTypes: [ContentType!]!, facets: [FacetRequest!], filters: [Filter!], first: Int, searchTerms: String, didYouMeanResults: Int): SearchResults!
  typeAhead(tenant: Tenant!, first: Int, input: String): QueryAssistResponse!

  """getGamesByGameDate | Stat API | Statmilk API"""
  getGamesByGameDate(startDate: String!, endDate: String!, timezone: Int!, sortOrder: SortOrder, status: [Status], stateStatus: [StateStatus], leagues: [StatsLeagues]): [Game]

  """getGamesByGameIds | Stat API | Statmilk API"""
  getGamesByGameIds(gameIds: [String]!): [Game]

  """getGamesBySportRadarIds | Stat API | Statmilk API"""
  getGamesBySportRadarIds(gameIds: [String]!): [Game]

  """getScores | Stat API | Statmilk API"""
  getScores(timezone: Int!, date: String, league: StatsLeagues, context: String, locale: String, tags: [Int], slugs: [String]): Scores

  """getStandings | Stats API | Statmilk API"""
  getStandings(permalink: String!, season: Int): StatsStanding

  """getGameCastBySlug | Stats API | Statmilk API"""
  getGamecastBySlug(slug: String!): StatsGamecast

  """getSchedule | Stats API | Statmilk API"""
  getSchedule(slug: String!, timezone: Int, season: Int): StatsSchedule

  """getGameCastByTagUUID | Stats API | Statmilk API"""
  getGameCastByTagUUID(uuid: String!): StatsGamecast
  getTagById(id: ID!, tenant: Tenant!): Tag!
  getTagsByPermalinks(permalinks: [String!]!, tenant: Tenant!): [Tag]
  getAllTeamsByPermalink(permalink: String!, tenant: Tenant!): [Tag!]!
  getSiteMap(permalink: String!, client: String!, tenant: Tenant!): Tag!

  """
  search for a tag by name or fragment. it is recommended (but not enforced) to provide at least 3 characters
  """
  findTagByMatchTerm(term: String!, tenant: Tenant!): [Tag!]!
  test: String!
  getUser(profileId: String, tenant: Tenant!): User
  getBlockedUsers: [User]
  getWbdContext: String
}

type QueryAssistResponse {
  results: [QueryAssistResult!]
}

type QueryAssistResult {
  term: String!
}

type Rating {
  classifier: String
  contentDescriptors: [String]
  ratingAuthority: String
}

type Reference {
  id: ID!

  """Title of the reference"""
  title: String

  """Description of the reference"""
  description: String

  """Illustration to display of the reference"""
  thumbnailUrl: String

  """Permalink of the reference"""
  permalink: String!

  """Url of the reference content"""
  url: String!

  """Author of the reference"""
  author: Author

  """Tags of the reference from tagapi"""
  tag: Tag!

  """Type of reference"""
  type: ReferenceType

  """Metadata of reference"""
  metadata: ReferenceMetadata

  """When reference was created"""
  createdAt: String!

  """When reference was updated"""
  updatedAt: String!
}

"""The object used for filtering references."""
input ReferenceInput {
  """The reference type we want to filter."""
  types: [String!]
}

type ReferenceMetadata {
  """
  Metadata's genres (i.e. breaking_news, analysis, rumors, game_action, live_event, etc.)
  """
  genres: [String!]

  """
  Metadata's labels is a list of tags that the reference was programmed into
  """
  labels: [Tag!]!

  """Metadata's provider name"""
  providerName: String

  """Image accreditation display information"""
  photoCredit: String

  """The content share url"""
  shareUrl: String

  """Video's Metadata"""
  video: VideoMetadata

  """Gamecast's Metadata"""
  gamecast: GamecastMetadata
}

type ReferenceStream {
  id: ID!

  """The Stream name"""
  name: String!

  """Tags of the reference from tagapi"""
  tag: Tag!

  """The Stream type"""
  type: String!

  """A list of References with optional limit query parameter"""
  references(limit: Int, filter: ReferenceInput): [Reference!]
}

"""GSP ReferenceType enumeration"""
enum ReferenceType {
  InternalArticle
  Video
  LiveVideo
  Highlight
  Gamecast
}

type Schedule {
  dateFrom: String
  dateTo: String
  offset: String
  feeds: [Feed]
}

type Score {
  away: Int
  home: Int
}

"""
@deprecated This type is deprecated and will be removed in a future version.
"""
type Scores {
  calendarNavigation: ScoresCalendarNavigation
  leagues: [ScoresLeague]
  gameGroups: [GameGroup]
  bettingLink: ScoresBettingLink
}

type ScoresBettingLink {
  id: String
  success: Boolean
  ctaText: String
  logo: String
  logoNight: String
  clickUrl: String
  disclaimerText: String
  disclaimerUrl: String
  showLinkout: String
  partner: ScoresOddsSportsbook
  betting: Boolean
  attributionText: String
}

type ScoresCalendarNavigation {
  previous: [NavigationElement]
  next: [NavigationElement]
  current: [NavigationElement]
}

type ScoresDescription {
  text: String
}

type ScoresEvent {
  id: String
  gamecast: String

  """Returns the tag for a given event's gamecast slug"""
  gamecastTag(tenant: Tenant!): TagV2
  name: String
  subName: String
  nameLabels: [ScoresEventNameLabel]
  descriptions: [ScoresDescription]
  gameDate: String
  sport: String
  site: String
  league: String
  status: String
  type: String
  boxScore: String
  stream: String
  participants: ScoresEventParticipant
  progress: ScoresProgress
  gameState: ScoresState
  current: Boolean
  gameEndDate: String
  metadata: ScoresMetadata
  odds: String
  gamecastInformation: String
}

type ScoresEventNameLabel {
  text: String
}

type ScoresEventParticipant {
  headers: ScoresEventParticipantHeader
  entries: [ScoresEventParticipantEntry]
}

type ScoresEventParticipantEntry {
  number: String
  logo: String
  name: String
  abbrev: String
  isWinner: Boolean
  values: [ScoresEventParticipantEntryValue]
}

type ScoresEventParticipantEntryFontFormatting {
  fontIsBold: Boolean
  fontColor: String
  fontColorNight: String
}

type ScoresEventParticipantEntryValue {
  value: String
  fontFormatting: ScoresEventParticipantEntryFontFormatting
}

type ScoresEventParticipantHeader {
  value: String
}

"""The ScoresGame is an Entity so it can be extended in other subgraphs."""
type ScoresGame {
  id: String
  gamecast: String

  """Returns the tag for a given game's gamecast slug"""
  gamecastTag(tenant: Tenant!): TagV2
  name: String
  descriptions: [ScoresDescription]
  gameDate: String
  sport: String
  site: String
  league: String
  status: String
  boxScore: String
  teamOne: ScoresGameTeam
  teamTwo: ScoresGameTeam
  progress: ScoresProgress
  gameState: ScoresState
  current: Boolean
  gameEndDate: String
  squadRide: SquadRide
  metadata: ScoresMetadata
  odds: String
  gamecastInformation: String

  """
  For sports that display a PeriodScores array, this indicates the maximum number of PeriodScores objects possible for a regulation length game/match
  """
  maxPeriodScores: Int
}

type ScoresGameTeam {
  name: String
  shortName: String
  abbrev: String
  hasPossession: Boolean
  rank: Int
  isWinner: Boolean
  logo: String
  score: String @deprecated(reason: "Use mainScore and secondaryScore instead")
  mainScore: String
  secondaryScore: String
  record: String
  odds: String
  colors: [String]
  permalink: String
  competitors: [ScoresTeamCompetitor]
  periodScores: [PeriodScore]

  """
  when true, the competitors are undecided, and the competitors array represents potential competitors for this team
  """
  virtual: Boolean
}

"""The League is an Entity so it can be extended in other subgraphs."""
type ScoresLeague {
  id: String
  slug: String
  tagV2(tenant: Tenant!): TagV2
  league: Int
  name: String
  current: Boolean
  tag: Tag @deprecated(reason: "Use slug field instead")
  queryParameters: ScoresLeagueQueryParameters
  children: [ScoresLeague]
  href: String @deprecated
}

type ScoresLeagueQueryParameters {
  context: String
  league: StatsLeagues
  date: String
}

type ScoresMetadata {
  name: String
  about: String
  startDate: String
  endDate: String
  status: String
  location: ScoresMetadataLocation
}

type ScoresMetadataLocation {
  name: String
  city: String
  state: String
  zip: String
  country: String
}

enum ScoresOddsSportsbook {
  Caesars
  Consensus
  SportRadar
  DraftKings
  FanDuel
  None
  Unknown
}

type ScoresProgress {
  network: String
  playPeriod: String
  playPeriodCondensed: String
  clock: String
  inningPhase: String
  round: String
  venue: String
}

type ScoresState {
  isRedZone: Boolean
  balls: Int
  strikes: Int
  outs: Int
  runners: ScoresStateRunners
}

type ScoresStateRunners {
  first: Boolean
  second: Boolean
  third: Boolean
}

type ScoresTeamCompetitor {
  abbrev: String
  logo: String
  name: String
  rank: Int
  slug: String

  """
  applicable in ScoresGame instances when some or all competitors of a ScoresGameTeam are TBD. This field identifies pairs of doubles players
  """
  team: Int
}

union SearchAsset = VideoV2 | Article | Channel | User | ExternalArticle

type SearchResult {
  searchAsset: SearchAsset
  contentModule: StandaloneContentModule
}

type SearchResults {
  connection: AssetConnection
  errors: [String]
  facetResponse: [FacetResponse!]
  didYouMeanResponse: QueryAssistResponse
}

enum SearchSource {
  TITLE
  USERNAME
  XPOST
  XAUTHOR
}

type Season {
  id: String
  current: Int
  end: String
  name: String
  start: String
  type: String
}

enum SemanticID {
  StatsGamecast
  StatsScoreboard
  StatsScorecard
  StatsBetting
  StatsVenue
  StatsInjuryReport
  StatsLiveOdds
  StatsSeasonPerformance
  StatsLeagueRankings
  StatsGameInfo
  StatsPreviousMeetings
  StatsLineScore
  StatsPlayPreview
  StatsPlaySummary
  StatsMatchTimeline
  StatsDriveChart
  StatsBaseball
  StatsPlays
  StatsGameStats
  StatsTeamComparison
  StatsOdds
  StatsSeasonLeaders
  StatsPlayersOnIce
  StatsHockeyGameState
  StatsPitchingInfo
  StatsLineup
  StatsSubstitutions
  StatsStandings
  StatsScores
  StatsSchedule
  StatsMoneyline
  StatsTotalPoints
  StatsSpread
  StatsScoringPlays
  StatsDrawNoBet
  Header
  UserHeader
  SearchBar
  Chat
  ExternalLink
  TrendingClips
  Ads
  TagFollowing
  TagRecommended
  TagOnboarding
  TagSearch
  ContentPremiumVideo
  ContentSocialFeed
  ContentCommunityFeed
  ContentHighlights
  ContentFullGameHighlights
  ContentChannelFeed
  ContentWhatsBuzzing
  ContentTopHeadlines
  ContentTrendingVideos
  UgcFromTheFans
  UgcFeed
  UgcPosts
  UgcComments
  Dummy
  AlertFollowingFeed
  AlertActivitiesFeed
  LiveAndUpcoming
  LiveNow
  LiveUpcoming
  ContentHomeLandscape
  ContentHomePortraitCollection
  ContentHomeHeadlines
  ContentHomeCommunityCollections
  ContentShortGameHighlights
  ContentTrendingBets
  RecForYou
  RecYouMightLike
  RecCreatorsInYourCommunities
  RecMostFollowedTeams
  RecMostFollowedLeagues
  RecTopInterests
  RecTopCreators
  RecRelatedCommunities
  StatsPlayerStats
  StatsScoresStrip
  StatsThreeWayMoneyline
  StatsHeadToHead
  StatsPlayerProp
  StatsPodium
  StatsPodiumEntry
  StatsRaceInfo
  AffiliateWatchBanner
}

enum SemanticType {
  AdsData
  ContentModuleData
  StatsData
  SocialData
  StatsPlaceholder
  TagData
  UserData
  AlertData
  Default
  RecommendationData
}

type Series {
  hash: String
  taxonomy: TaxonomyTerm
  season: String
  tournament: Tournament
  id: ID
  series_name: String
  territories_available: [Territories]
  start_date: String
  events(filter: EventFilterInput): [Event]
}

type Serieses {
  series: [Series]
  total: Int
  index_start: Int
  index_end: Int
}

enum SeriesSort {
  season
  start_date
  id
  series_name
}

type Settings {
  spoilers_enabled: String
  alerts: [AlertPreference!]
}

type Show {
  hash: String
  taxonomy(tenant: Tenant!): TaxonomyTerm
  id: String
  titleId: String
  title: String
  originalTitle: String
  genreList: String
  highlightList: String
  airDateTime: String
  lang: String
  begin: String
  end: String
  rate: String
  serie: String
  season: String
  episode: String
  storyline: String
  offset: String
  franchiseName: String
  franchiseId: String
  ratingArgentina: String
  ratingBrasil: String
  ratingMexico: String
  length: String
  summary: String

  """
  Status Values (derived from "begin", "end" and "offset" values): "estimated" (before)  || "current" (during)  || "actual" (after)
  """
  status: String
}

type Slide {
  id: Int
  slideNumber: Int
  title: String!
  featuredMedia: Element!
  elements: [Element]
}

type SocialLinks {
  twitter: String
  youtube: String
  instagram: String
  twitch: String
  tiktok: String
}

type SocialMediaHandle {
  platform: String
  handle: String
}

type SocialWidget {
  clientId: String!
  widgetId: String!
  fireReactionId: String
  targetGroupId: String
  commentBoardReactionSpaceId: String
  type: String!
  count: Int
  liveLikeUserReaction: CustomLiveLikeUserReaction
}

enum SortDirections {
  asc
  desc
}

enum SortOrder {
  Ascending
  Descending
}

type Sport {
  has_media: Boolean
  name: String
  territories_available: [Territories]
  leagues(id: ID): [League]
  id: ID
  event_image: String
  icon_light: String
  icon_dark: String
  gracenote_id: String
  sportradar_id: String
}

type SportMetaData {
  league: StatsLeagues
  sport: StatsSport
}

type Sports {
  sports: [Sport]
  total: Int
  index_start: Int
  index_end: Int
}

type SquadRide {
  id: String
  outcome: String
}

type StandaloneContentModule implements ContentModule {
  """Type of the content of a content module, e.g: Article, Video, Tweet"""
  type: ContentModuleType!

  """ID of the content of a content module."""
  contentID: String

  """
  Metadata containing community tag, author, and brand information for logos and display.
  """
  metaData: ModuleMetaData

  """Ads Configuration | Ads API"""
  adsConfig: AdsConfiguration
  id: ID!

  """Also known as Headline, that's the heading text of a content module."""
  title: String!

  """
  Also known as Commentary, short description of the content of a content module.
  """
  description: String!

  """Thumbnail URL of the content module"""
  thumbnail: String!

  """
  Audit only field to capture the last system or person that updated the content module.
  """
  lastModifiedBy: String

  """The content object, will be resolved by one of the downstream graphs."""
  content: ProgrammedContent!

  """Content module orientation, one of: Landscape or Portrait"""
  orientation: ModuleOrientation!

  """
  Date and Time when a content module will not be visible anymore for end users. The state will be `UNPROGRAMMED`.
  """
  expiresAt: Date

  """
  Date and Time when a content module will start to be visible for end users. The state will be `SCHEDULED`.
  """
  scheduledDate: Date

  """
  List of possible states of content module. One of `SCHEDULED`, `PROGRAMMED` or `UNPROGRAMMED`.
  """
  state: ModuleState

  """
  List of Channels/Components (tag + semanticID) a content module is programmed to.
  """
  components: [ComponentModule]

  """Indicates if a push notification was sent to the content module."""
  isAlerted: Boolean

  """List of countries that a content module will be visible."""
  allowedCountries: [String]
  composites: [PackageContentModule]
  commentsEnabled: Boolean

  """Indicates to what tagUUID the content module was alerted to."""
  alertedChannelTagUUID: String

  """Date and time that a content module was last updated."""
  updatedAt: Date
  thumbnailAccreditation: String
  thumbnailCopyright: String
  position: Int
  isPositionLocked: Boolean
  positionLockExpiresAt: Date
  contentMetadata: ContentMetadata

  """Date and time that the Content Modules was created."""
  insertedAt: Date

  """
  Date and Time that the Content Module was last updated, considering the programming relevant fields (title, description, thumbnail, contentID/contentType)
  """
  programmingUpdatedAt: Date

  """
  Identifies content modules created with the same contentID and contentType for Social features.
  """
  wrapperContentModuleId: ID
  hidden: Boolean

  """
  Date and Time when a hidden content module will automatically become visible again.
  """
  hiddenExpiresAt: Date
  alertRanks(limit: Int = 10): [AlertRank]!
  socialWidgets: [SocialWidget]
}

enum StateStatus {
  Scheduled
  InProgress
  Complete
}

type StatsBetOffer {
  jsonResponse: String
}

"""
The StatsBetting is an Entity so it can be extended in other subgraphs.
"""
type StatsBetting {
  id: ID!
  jsonResponse: String
}

"""
The jsonResponse field will soon be deprecated. Use new GraphQL types IF they exist.
jsonResponse is being split into native types. Currently GraphQL types exist for Gamecast Content Modules / Scoreboards, not yet the full Gamecast experience.
New types exist for the following StatMilk payloads: **scoreLeaderboard**, **gameDate**, **linescore**, **podium**, **raceInfo**, **scoreboard**, **sport**, **status**, **venue**, **pbp**
"""
type StatsGamecast {
  slug: String!
  tag(tenant: Tenant): TagV2
  scoreLeaderboard: ScoresEvent
  gameDate: String
  linescore: StatsLinescore
  podium: StatsPodium
  raceInfo: StatsRaceInfo
  scoreboard: StatsScoreboard
  sport: StatsSport
  status: StatsGameStatus
  venue: StatsVenue
  pbp: StatsPbp

  """
  The jsonResponse field will soon be deprecated. Use new GraphQL types IF they exist.
  """
  jsonResponse: String
}

enum StatsGameStatus {
  Scheduled
  InProgress
  Complete
  Unknow
  Closed
}

enum StatsLeagues {
  MLB
  Soccer
  NHL
  NCAAF
  NCAABB
  NFL
  NBA
  WNBA
  OlympicBasketball
  GLeague
  Other
  Olympics
  Unknown
  Golf
  Tennis
  Formula1
  NCAABBW
  NASCAR
  Unrivaled
}

type StatsLinescore {
  gameState: StatsLinescoreGameState
  headers: [StatsLinescoreValue]
  summaryHeaders: [StatsLinescoreValue]
  teamOne: StatsLinescoreTeam
  teamTwo: StatsLinescoreTeam
  title: String
}

type StatsLinescoreBatter {
  atBats: Int
  average: Float
  player: String
  totalHits: Int
}

type StatsLinescoreDiamond {
  first: Boolean
  second: Boolean
  third: Boolean
}

type StatsLinescoreGameState {
  balls: Int
  batter: StatsLinescoreBatter
  outs: Int
  pitcher: StatsLinescorePitcher
  runners: StatsLinescoreDiamond
  strikes: Int
}

type StatsLinescorePitcher {
  player: String
  totalPitches: Int
  totalStrikeouts: Int
}

type StatsLinescoreTeam {
  colors: [String]
  logo: String
  name: String
  record: String
  summaryValues: [StatsLinescoreValue]
  values: [StatsLinescoreValue]
}

type StatsLinescoreValue {
  value: String
}

type StatsPbp {
  tabs: StatsPbpTabs
  scoringSummary: StatsPbpTabGrouping
  pbpPreview: StatsPbpPreview
  plays: [StatsPbpPlay!]
}

type StatsPbpDriveChart {
  currentPosition: Float
  startingPosition: Float
  firstDownPosition: Float
  direction: String
}

type StatsPbpDriveSummary {
  primaryDescription: String
  secondaryDescription: String
  logo: String
  isRedzone: Boolean
}

type StatsPbpPeriodGrouping {
  description: String
  collapsed: Boolean
  collapsable: Boolean
  plays: [Int!]
}

type StatsPbpPlay {
  sequence: Int
  summary: String
  gameProgress: String
  playStoppage: Boolean
  teamOneScoringPlay: Boolean
  teamTwoScoringPlay: Boolean
  logo: String
  gameProgressPrimary: String
  scoreTeamOne: Int
  scoreTeamTwo: Int
  teamName: String
  boldPenalty: Boolean
  gameProgressSecondary: String
}

type StatsPbpPreview {
  description: String
  id: String
  groupings: [StatsPbpPeriodGrouping!]
  driveSummary: StatsPbpDriveSummary
  driveChart: StatsPbpDriveChart
  gameStateDescription: String
  formatting: StatsPbpTextFormatting
  useGameProgressSecondary: Boolean
}

type StatsPbpTabGrouping {
  description: String
  id: String
  groupings: [StatsPbpPeriodGrouping!]!
  useGameProgressSecondary: Boolean
}

type StatsPbpTabs {
  scoringSummary: StatsPbpTabGrouping
  byPeriod: StatsPbpTabGrouping
  penalties: StatsPbpTabGrouping
}

type StatsPbpTextFormatting {
  fontColor: String
  fontIsBold: Boolean
  fontIsItalic: Boolean
  fontColorNight: String
  textClass: String
}

type StatsPodium {
  entries: [StatsPodiumEntry]
  title: String
}

type StatsPodiumEntry {
  logo: String
  name: String
  place: String
  result: String
  subResult: String
}

type StatsRaceInfo {
  distance: String
  distanceUnit: String
  laps: String
  name: String
  status: StatsGameStatus
  type: String
}

type StatsSchedule {
  adPlacement: [StatsScheduleAdPlacement]
  league: String
  name: String
  slug: String!
  scheduleGroupings: [StatsScheduleGrouping]
}

type StatsScheduleAdPlacement {
  adId: String
  gameRowIndex: Int
  groupIndex: Int
  repeatOffset: Int
}

type StatsScheduleEntry {
  group: String
  current: Boolean
  date: String
  slug: String
  homeAway: String
  isoUtcDatetime: String
  opponent: String
  opponentLogo: String
  resultDescription: String
  startTimeTbd: Boolean
  status: StatsGameStatus
  location: ScoresMetadataLocation
  resultCode: StatsScheduleResultCode
  ticketInfo: StatsScheduleTickets
}

type StatsScheduleGrouping {
  current: Boolean
  title: String
  entries: [StatsScheduleEntry]
  key: [StatsScheduleKey]
  link: StatsScheduleLink
}

type StatsScheduleKey {
  value: String
  color: String
  returnColor: Boolean
}

type StatsScheduleLink {
  title: String
  type: String
  value: String
}

type StatsScheduleResultCode {
  color: String
  colorNight: String
  value: String
}

type StatsScheduleTickets {
  url: String
  minPrice: String
}

type StatsScoreboard {
  gameDate: String
  progress: ScoresProgress
  teamOne: ScoresGameTeam
  teamTwo: ScoresGameTeam
}

type StatsScoreboardTeam {
  abbrev: String
  bonus: Boolean
  colors: [String]
  competitors: [ScoresTeamCompetitor]
  doubleBonus: Boolean
  hasPossession: Boolean
  hasPowerPlay: Boolean
  isRedZone: Boolean
  isWinner: Boolean
  logo: String
  name: String
  odds: String
  periodScores: [PeriodScore]
  permalink: String
  rank: Int
  record: String
  score: String
  shortName: String
  timeoutsRemaining: Int
  totalTimeouts: Int

  """
  when true, the competitors are undecided, and the competitors array represents potential competitors for this team
  """
  virtual: Boolean
}

enum StatsSport {
  Football
  Basketball
  Baseball
  Hockey
  Soccer
  Other
  Golf
  Tennis
  Motorsports
}

type StatsStanding {
  slug: String
  tag: Tag @deprecated(reason: "Use slug field instead")
  season: Int
  name: String
  standingGroupings: [StatsStandingGrouping]
}

type StatsStandingAdPlacement {
  adId: String
  index: Int
}

type StatsStandingEntry {
  title: String
  current: Boolean
  separator: StatsStandingSeparator
  headers: [StatsStandingHeader]
  teams: [StatsStandingTeam]
  keys: [StatsStandingKey]
}

type StatsStandingGrouping {
  title: String
  entries: [StatsStandingEntry]
  adPlacement: [StatsStandingAdPlacement]
}

type StatsStandingHeader {
  title: String
}

type StatsStandingKey {
  value: String
  color: String
  returnColor: Boolean
}

type StatsStandingSeparator {
  color: String
  index: Int
}

type StatsStandingTeam {
  color: String
  number: String
  logo: String
  name: String
  superscript: String
  current: Boolean
  values: [StatsStandingValue]
  returnColor: Boolean
  prefixSuperscript: String
  slug: String
  tag: Tag @deprecated(reason: "Use slug field instead")
}

type StatsStandingValue {
  value: String
}

type StatsVenue {
  location: String
  stadium: String
  weatherEmoji: String
  weatherPrimary: String
  weatherSecondary: String
}

enum Status {
  Scheduled
  Postponed
  Unnecessary
  Suspended
  WDelay
  FDelay
  ODelay
  Created
  Cancelled
  InProgress
  Reopened
  Complete
  Closed
  TimeTBD
  Maintenance
  IfNecessary
  FlexSchedule
  Halftime
  Delayed
  Interrupted
  Abandoned
}

type StreamMetaData {
  id: String
  headline: String
  subtype: String
  weight: Float
  _id: MongoID

  """The reference stream"""
  referenceStream: ReferenceStream
}

type Tag {
  id: ID!

  """A unique name for the tag in a URL friendly format (i.e. nfl)"""
  permalink: String!

  """The root tag in the particular subtree"""
  root: Tag
  menu(tenant: Tenant!): Menu

  """Full display name for the tag"""
  name: String!

  """Programmable abbreviation to avoid complicated rules in the client"""
  abbreviation: String

  """
  Active is a control for discoverability; inactive tags are hidden by default in searchTags
  """
  active: Boolean

  """The logo filename (currently) assumes that it is the tail of a URI"""
  logoFileName: String

  """Type of the tag and the entity it represents"""
  type: TagType

  """
  The primary color associated with the tag, represented as a string in hexadecimal format
  """
  color1: String

  """
  The secondary color associated with the tag, represented as a string in hexadecimal format
  """
  color2: String

  """
  A boolean value indicating whether the tag should display a logo or not
  """
  displayLogo: Boolean

  """
  The date and time when the tag expires, represented as a string in ISO 8601 format
  """
  expiresAt: String

  """A URL for the tag the origin resource"""
  href: String

  """Indicates if a tag """
  newsletterEnabled: Boolean

  """The parent tag"""
  parent: Tag

  """
  A display hint for relative positioning. Siblings should be well-ordered, but positions don't freely translate elsewhere
  """
  position: Int

  """The URL BR Shop related to tag or campaign"""
  shopUrl: String

  """A short name for representing the tag"""
  shortName: String

  """Site section the tag belongs to"""
  site: String

  """
  The color associated with a team, represented as a string in hexadecimal format
  """
  teamColor: String

  """
  A URL linking to a page where tickets for events associated with the tag can be purchased
  """
  ticketsLink: String

  """A list of child tags associated with a tag"""
  children: [Tag!]!

  """A list of parents tags associated with a tag"""
  parents: [Tag!]!
}

input TagComponent {
  tagUUID: String!
  semanticID: SemanticID!
  position: Int
  isPositionLocked: Boolean
  positionLockExpiresAt: Date
  isPinned: Boolean
}

type Tagging {
  tags: [String]
  shows: [String]
  _id: MongoID
  events: [Event]
  tournaments: [Tournament]
  competitors: [Competitor]
}

type TagGroup {
  schemaVersion: String
  tenant: String
  uuid: String!
  cmsId: String
  isPublished: Boolean
  language: String
  slug: String!
  displayName: String
  children: [TagV2]
  type: EnumTagGroupType!
  _id: MongoID!
}

input TagInput {
  id: String
}

input TagSearchParamsInput {
  """
  Term or characters to search for.
  
  Requires a minimum of 2 characters to start getting results.
  """
  term: String!

  """Whether or not the tag should be visible in the Content Tool"""
  isVisibleInContentTool: Boolean

  """Whether or not the tag should be visible in the Programming Tool"""
  isVisibleInProgrammingTool: Boolean

  """Filter search results to only Tags that have a Channel"""
  isChannel: Boolean
}

input TagsQueryInput {
  uuids: [String!]
  slugs: [String!]
}

enum TagType {
  Aggregated
  Archived
  Blog
  CampaignHub
  Chain
  City
  Conference
  Division
  Editorial
  Event
  ExternalContributor
  GridHub
  Grouping
  LeadWriter
  League
  Location
  Moment
  National
  Person
  Sport
  State
  Tag
  Talent
  Team
  Topic
  Venue
  Video
}

enum TagTypeV2 {
  Conference
  Creator
  Division
  Editor
  Editorial
  Event
  GameCast
  Interest
  League
  Page
  Player
  Person
  Sport
  Team
}

type TagV2 {
  slug: String!
  type: TagTypeV2
  parent: TagV2
  root: TagV2
  schemaVersion: String
  tenant: String
  uuid: String!
  cmsId: String
  foreignId: String
  isPublished: Boolean
  language: String
  displayName: String
  description: String
  shortName: String
  abbreviation: String
  eyebrow: String
  ticketLink: String
  isChannel: Boolean
  isFeatured: Boolean
  gameStatus: String
  channelState: EnumTagV2ChannelState
  logo: Image
  followingMetadata: FollowingMetadata
  startTime: Date
  endTime: Date
  changed: String @deprecated(reason: "use field updatedAt which is a correctly typed Date")
  updatedAt: Date
  parents: [TagV2]
  children: [TagV2]
  colorPrimary: String
  colorSecondary: String
  isVisibleContentTool: Boolean
  isVisibleProgrammingTool: Boolean
  creatorTier: CreatorTier
  _id: MongoID!
  watchInfo(
    """
    Optionally specify a specific affiliate to return. If omitted all affiliates will be returned
    """
    providerName: String
  ): [WatchInfo]
  menu: Menu
  locationRelatedTags: [TagV2]
  tagUUID: String
  followersCount(tenant: Tenant!): Int!
  recommendedTags(type: TagTypeV2, limit: Int = 10): [ChannelRecommenderResult!]!
  recommendedArticles(limit: Int = 10): [DsContentModelResult!]!
  followers(limit: Int!, tenant: Tenant!, last_user_id: String): [User]
  following(limit: Int!, tenant: Tenant!, creatorBoltId: String): [TagV2]
  settings: Settings
  notifications: [Notifications]
  user: User
}

type TagV2Connection {
  totalCount: Int!
  edges: [TagV2Edge!]!
  pageInfo: PageInfo!
}

type TagV2Edge {
  cursor: ComponentCursor!
  node: TagV2!
}

type TaxonomyReference {
  taxonomyId: Identifier
}

type TaxonomyReferenceGroup {
  kind: String
  taxonomyReferences: [TaxonomyReference]
}

type TaxonomyTerm {
  schemaVersion: String
  tenant: String
  uuid: String!
  cmsId: String!
  isPublished: Boolean
  language: String
  type: String
  id: String!
  parentId: String
  name: String
  description: String
  created: String
  changed: String
  sportsRadarId: String
  tournamentId: String
  year: String
  image: Image
  _id: MongoID!
}

enum TaxonomyType {
  seriesTaxonomy
  showTaxonomy
}

type Team {
  abbreviation: String
  draws: String
  logo: String
  losses: String
  market: String
  mascot: String
  name: String
  wins: String
}

"""GSP Tenant enumeration"""
enum Tenant {
  aewGame
  bleacherReport
  estadioArgentina
  estadioBrazil
  estadioChile
  ncaa
}

enum Tenants {
  estadioChile
  hboMaxBrazil
  hboMaxMexico
  bleacherReport
  estadioArgentina
}

enum Territories {
  USA
}

input TextPollInput {
  uploadId: ID
  contentId: ID
  question: String!
  options: [TextPollOptionInput!]
  timeout: String
  interactiveUntil: String
  tagUUIDs: [String!]!
  widget_attributes: [TextPollWidgetInput!]
  semanticId: SemanticID
}

input TextPollOptionInput {
  description: String!
  id: ID
}

input TextPollWidgetInput {
  key: String!
  value: String!
}

type Tournament {
  hash: String
  display_name: String
  has_media: Boolean
  name: String
  territories_available: [Territories]
  sport: Sport
  league: League
  team_tournament: Boolean
  id: ID
  display_name_short: String
  is_popular: Boolean
  is_featured: Boolean
}

type Tournaments {
  tournaments: [Tournament]
  total: Int
  index_start: Int
  index_end: Int
}

type TrendingChannelResult {
  tagV2: TagV2!
  rank: Int!
}

type TrendingResult implements DsContentModelResult {
  contentModule: StandaloneContentModule
  type: ContentModuleType!
  contentID: String!
  rank: Int!
}

"""A Tweet Entity from X"""
type Tweet {
  """Tweet Uuid"""
  id: ID!

  """Type of the tweet"""
  type: TweetType!

  """The Tweet Author"""
  author: TwitterUser

  """A Data-Struct of the Tweet"""
  data: TweetData

  """Additional Media referenced by the Tweet"""
  media: [TweetMedia]

  """Another Tweet that is referenced by this Tweet"""
  referencedTweet: Tweet
}

"""A Tweet's Attachments"""
type TweetAttachments {
  """MediaKeys"""
  mediaKeys: [String]

  """Ids for Polls"""
  pollIds: [String]
}

"""A Tweet's Primary Data"""
type TweetData {
  """Tweet AuthorId"""
  authorId: String!

  """Tweet Attachments"""
  attachments: TweetAttachments

  """Tweet created Date"""
  createdAt: String!

  """Tweet metrics"""
  publicMetrics: TweetMetrics!

  """Tweet text"""
  text: String!

  """Tweet engagement entities"""
  entities: TweetEntities

  """Other tweet entities referenced"""
  referencedTweets: [TweetReference]
}

"""Social Media Entities"""
type TweetEntities {
  """Hash Tags"""
  hashTags: [TweetHashtag]

  """Urls"""
  urls: [TweetUrl]

  """Mentions"""
  mentions: [TweetMention]
}

"""Tweet HashTag"""
type TweetHashtag {
  """Start"""
  start: Int!

  """End"""
  end: Int!

  """Tag"""
  tag: String!
}

"""Tweet Media"""
type TweetMedia {
  """Media Type"""
  type: TweetMediaType!

  """Height in px"""
  height: Int!

  """Width in px"""
  width: Int!

  """MediaKey"""
  mediaKey: String!

  """Url"""
  url: String

  """Preview Image Url"""
  previewImageUrl: String

  """Variant"""
  variants: [TweetVariant]
}

enum TweetMediaType {
  ANIMATED_GIF
  PHOTO
  VIDEO
}

"""Tweet Mention"""
type TweetMention {
  """Start"""
  start: Int!

  """End"""
  end: Int!

  """Username"""
  username: String!
}

"""A Tweet's Metrics"""
type TweetMetrics {
  """Bookmark Count"""
  bookmarkCount: Int!

  """Impression Count"""
  impressionCount: Int!

  """Like Count"""
  likeCount: Int!

  """Quote Count"""
  quoteCount: Int!

  """Reply Count"""
  replyCount: Int!

  """Retweet Count"""
  retweetCount: Int!
}

"""Tweet Reference"""
type TweetReference {
  """Id"""
  id: ID!

  """Reference Type"""
  referenceType: String
}

enum TweetType {
  ORIGINAL
  REPLIED_TO
  QUOTED
  RETWEETED
}

"""Tweet Url"""
type TweetUrl {
  """Start"""
  start: Int!

  """End"""
  end: Int!

  """Url"""
  url: String!

  """Display Url Format"""
  displayUrl: String!

  """Expanded Url"""
  expandedUrl: String!
}

"""Tweet Variant"""
type TweetVariant {
  """BitRate"""
  bitRate: Int

  """Content Type"""
  contentType: String!

  """Url"""
  url: String!
}

"""A Twitter User"""
type TwitterUser {
  """Twitter User Id"""
  id: ID!

  """Name of the User"""
  name: String!

  """Username of the User"""
  username: String!

  """Whether the User is Verified"""
  verified: Boolean!

  """URL of the User's Profile Image"""
  profileImageUrl: String!
}

type UGCImagePoll {
  id: ID!

  """ LiveLike resolver for ImagePoll """
  liveLikeImagePoll: LiveLikeImagePoll

  """ LiveLike resolver for ImagePoll userVote """
  liveLikeUserVote: LiveLikeImagePollVote
}

type UGCPost {
  id: ID!

  """ LiveLike resolver for RichPost """
  liveLikeRichPost: LiveLikeRichPost
  uploadId: String
}

type UGCTextPoll {
  id: ID!

  """ LiveLike resolver for TextPoll """
  liveLikeTextPoll: LiveLikeTextPoll

  """ LiveLike resolver for TextPoll userVote """
  liveLikeUserVote: LiveLikeTextPollVote
}

type UGCWidget {
  clientId: String!
  widgetId: String!
  type: String!

  """ LiveLike resolver for total reactions on type REACTION_SPACE | COMMENT_BOARD
  """
  count: Int

  """ LiveLike resolver for user reaction on type REACTION_SPACE """
  liveLikeUserReaction: LiveLikeUserReaction
  fireReactionId: String
  targetGroupId: String
}

input UpdatePostInput {
  uploadId: ID
  content: String!
  postId: String!
}

input UpdateTextPollInput {
  uploadId: ID
  contentId: ID
  question: String!
  options: [TextPollOptionInput!]
  timeout: String
  interactiveUntil: String
  widget_attributes: [TextPollWidgetInput!]
  pollId: String!
  semanticId: SemanticID
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

type UrlMapping {
  uploadUrl: String!
  mediaId: String!
  status: String!
}

type User {
  profileId: String
  recommendedTeams: [TrendingChannelResult!]
  recommendedLeagues: [TrendingChannelResult!]
  recommendedVideos: [TrendingResult!]
  id: String
  creatorId: String
  following(tenant: Tenant): Int
  followers(tenant: Tenant): Int
  type: String
  liveLikeToken: String
  liveLikeProfileId: String
  avatar: Avatar
  name: Name
  tags: [TagV2]
  badges: [BadgeComponent]
  favoriteTeams: [TagV2]
  scores(date: String, context: String, league: String): Scores @deprecated(reason: "This field is deprecated and will be removed in a future version. Please use alternative scoring endpoints.")
  profileDescription: String
  socialLinks: SocialLinks
  creatorTag: TagV2
  globalBan: String
  settings: Settings
}

type UserDestination {
  """
  The Content Module ID. It can be null when the alert is sent to the Channel
  """
  contentModuleId: ID
  contentModule: StandaloneContentModule
  tag: TagV2!
}

input UserTagInput {
  tagUUID: String!
  notifications: [NotificationInput]
  alerts: [AlertInput]
  weight: Float
}

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

type V2VResult implements DsContentModelResult {
  video: StandaloneContentModule
  type: ContentModuleType!
  contentID: String!
  score: Float!
}

type Venue {
  address: String
  capacity: String
  city: String
  country: String
  name: String
  state: String
  zip: String
  time_zone: String
  id: ID
}

type Venues {
  venues: [Venue]
  total: Int
  index_start: Int
  index_end: Int
}

type Video {
  schemaVersion: String
  tenant: String
  uuid: String!
  cmsId: String!
  isPublished: Boolean
  language: String
  thumbnail: String
  mediaId: String
  title: String
  headline: String
  subHeadline: String
  duration: String
  cardLabel: String
  sortDate: String
  collectionName: String
  episodeNumber: String
  tagging: Tagging
  created: String
  changed: String
  _id: MongoID!
  events: [Event] @deprecated(reason: "Use Video.tagging.events.")
}

type VideoAnalytics {
  """Video Analytics id"""
  id: String!

  """Video Analytics creationTimePeriod"""
  creationTimePeriod: String

  """Video Analytics publishMethod"""
  publishMethod: String

  """Video Analytics publishedAt time"""
  publishedAt: String

  """Video Analytics rating"""
  rating: String

  """Video Analytics rule Id"""
  ruleId: String

  """Video Analytics rule Name"""
  ruleName: String

  """Video Analytics stream"""
  stream: String

  """Video Analytics title"""
  title: String

  """Video Analytics video Id"""
  videoId: Int

  """Video Analytics video Type from vid - (i.e. video/highlight)"""
  videoType: String

  """Video Analytics team"""
  team: String

  """Video Analytics league"""
  league: String
}

type VideoAppName {
  allowValues: [String]
}

enum VideoContentType {
  CONTENT_TYPE_UNSPECIFIED
  CONTENT_TYPE_VOD
  CONTENT_TYPE_LIVE
  CONTENT_TYPE_FULL_EVENT_REPLAY
  CONTENT_TYPE_START_OVER
  CONTENT_TYPE_ADVERTISEMENT
  CONTENT_TYPE_CLIP
  CONTENT_TYPE_QUICKVOD
}

enum VideoContentTypeFilter {
  FULL_LENGTH
  CLIP
}

"""Passing multiple filter values is currently **not supported**"""
input VideoFiltersInput {
  """
  Provides the ability to filter video clips to a specific Team. Value passed should be the **sportradar_id** (ex. `sr:competitor:1234`)
  """
  team: String

  """
  Provides the ability to filter video clips to a specific Event. Value passed should be the **sportradar_id** (ex. `sr:match:1234`)
  """
  event: String
}

type VideoImpressionTracking {
  """Video Impression Tracking name"""
  name: String

  """Video Impression Tracking url"""
  url: String
}

type VideoMetadata {
  """Video's analytics"""
  analytics: VideoAnalytics

  """Video's duration"""
  duration: Int

  """Video's hlsUrl"""
  hlsUrl: String

  """Video's mp4Url"""
  mp4Url: String

  """Video's videoUrl"""
  videoUrl: String

  """Video's Id"""
  videoId: Int

  """Video's impressionTracking"""
  impressionTracking: [VideoImpressionTracking]

  """Video's width"""
  width: Int

  """Video's height"""
  height: Int

  """Video's state from airchain and hotmic (i.e. live, upcoming, etc.)"""
  state: String
}

input VideoMetadataInput {
  videoId: String!
  newState: VideoState!
}

enum VideoState {
  UPCOMING
  LIVE
  ENDED
  VOD
}

type VideoTitle {
  localizations: [Localization]
  scope: String
  type: String
}

enum VideoType {
  VIDEO_TYPE_CLIP
  VIDEO_TYPE_EPISODE
  VIDEO_TYPE_LIVE
  VIDEO_TYPE_MOVIE
  VIDEO_TYPE_PROMO
  VIDEO_TYPE_STANDALONE
  VIDEO_TYPE_STANDALONE_EVENT
  VIDEO_TYPE_TRAILER
  VIDEO_TYPE_UNSPECIFIED
}

type VideoV2 {
  schemaVersion: String
  tenant: String
  cmsId: String
  uuid: String
  eventId: String!
  title: String
  description: String
  headline: String
  subHeadline: String
  isPublished: Boolean
  playable: Boolean
  durationSeconds: Float
  height: Int
  width: Int
  contentType: VideoContentType
  videoSource: String
  videoType: VideoType
  videoState: VideoState
  isPtScheduled: Boolean
  program: Program
  offering: Offering
  deliverableImage: Image
  tags: [TagV2]
  createdDateTime: String @deprecated(reason: "use field createdAt which is a correctly typed Date")
  lastModifiedDateTime: String @deprecated(reason: "use field updatedAt which is a correctly typed Date")
  createdAt: Date
  updatedAt: Date
  _id: MongoID!

  """
  trendingRank | Data Services API
  
  Returns the Trending Rank from [1,100]. Returns null if not trending.
  """
  trendingRank: Int
  recommendedVideos(countryCode: String, version: Int = 0, aspectRatio: AspectRatio = Any, limit: Int = 10): [V2VResult!]!
}

type VideoV2Metadata {
  state: VideoState
}

type VideoV2TagData {
  """List of tags on a given VideoV2"""
  uuid: String!

  """The type of tag for the associated id"""
  type: TagTypeV2!
}

type VideoV2TagIds {
  """VideoV2 eventId"""
  eventId: String!

  """Ordered list of tag UUIDs associated with the video"""
  tagData: [VideoV2TagData]
}

enum VisibilityReason {
  HAS_DATA
  NO_DATA
  INSIDE_TIME_WINDOW
  OUTSIDE_TIME_WINDOW
}

"""
Returns Affiliate TV Link information for Games/Events
if any are configured for a given GameCast tag/channel
"""
type WatchInfo {
  name: String
  url: String
  text: [String]
  logoUrl: String
}
